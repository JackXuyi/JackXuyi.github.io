---
title: 正则
date: 2024-09-24 18:19:52
tags: [JavaScript]
---

## 有限状态机

### 定义

有限状态机是一个五元组 (Q, Σ ,δ, q0, F)：

- Q 是一个有穷集合，叫 状态集
- Σ 是一个有穷集合，叫 字母表
- δ : Q × Σ → Q 是 转移函数
- q0 ∈ Q 是 起始状态.
- F ⊆ Q 是 接受状态

### 执行流程

从开始状态，根据不同的输入，自动进行状态转移的过程，直到进入接受状态为止

### 确定有限状态自动机（DFA）

DFA 的每一个状态对于字母表中的每一个符号总是恰好有一个转移箭头射出。其确定性在于，在一个状态下，输入一个符号，一定是转移到确定的状态，没有其他的可能性

### 非确定有限状态自动机（NFA）

NFA 中每一个状态对于字母表的每一个符号（如：0/1）可能有多个箭头射出。其不确定性在于，在一个状态下，输入一个符号，可能转移到 n 个状态，出现了多种状态转移。另外 NFA 中箭头的标号可以是 ε（空转移，即：未输入任何符号也可转移到另一个状态）

## 组成部分

- 解析器：负责解析正则表达式字符串，将其转换为内部表示形式，如状态机、有向图等。
- 状态机：根据解析器生成的内部表示形式，构建一个有限状态自动机，用于在文本中搜索匹配项。
- 匹配器：利用状态机在输入文本中进行匹配，根据正则表达式的模式和规则，找到符合条件的子串。
- 捕获器：用于捕获匹配过程中产生的结果，如分组捕获、非捕获组等。
- 替换器：用于执行替换操作，根据正则表达式中的替换规则，将匹配的子串替换为新的内容。

## 执行流程

暂时无法在飞书文档外展示此内容

## 代码实现思路

```javascript
class Value {
  constructor(value) {
    this.value = value
  }

  equal = (char) => {
    return char === this.value
  }
}

class Token {
  constructor(value, meta) {
    this.value = new Value(value)
    this.meta = meta
  }

  matchMeta = (c) => {
    return this.meta && this.value.equal(c)
  }

  matchChar = (c) => {
    return !this.meta && this.value.equal(c)
  }

  match = (c) => {
    if (this.matchMeta('.')) {
      return typeof c !== 'undefined'
    } else {
      return this.matchChar(c)
    }
  }
}

class MyPattern {
  constructor(tokens, matchString) {
    this.tokens = tokens
    this.matchString = matchString
  }

  matchStar = (i, j) => {
    const token = this.tokens[i]
    const ch = this.matchString[j]
    if (token && token.match(ch) && this.matchStar(i, j + 1)) {
      return true
    } else {
      return this.matchStr(i + 2, j)
    }
  }

  matchStr = (i, j) => {
    const token = this.tokens[i]
    const nextToken = this.tokens[i + 1]
    if (token && token.matchMeta('$')) {
      return j >= this.matchString.length
    } else if (token && nextToken && nextToken.matchMeta('*')) {
      return this.matchStar(i, j)
    } else if (token && token.match(this.matchString[j])) {
      return this.matchStr(i + 1, j + 1)
    }

    return false
  }

  match() {
    if (this.matchStr(1, 0)) {
      return true
    }

    return false
  }
}

class MyRegexp {
  constructor(regexp) {
    this.regexp = regexp
  }

  compile = () => {
    this.tokens = []
    for (let i = 0; i < this.regexp.length; i++) {
      switch (this.regexp[i]) {
        case '*': {
          this.tokens.push(new Token('*', true))
          break
        }
        case '^': {
          this.tokens.push(new Token('^', true))
          break
        }
        case '$': {
          this.tokens.push(new Token('$', true))
          break
        }
        case '.': {
          this.tokens.push(new Token('.', true))
          break
        }
        default: {
          this.tokens.push(new Token(this.regexp[i], false))
          break
        }
      }
    }
  }

  match = (str) => {
    if (!this.tokens) {
      this.compile()
    }
    return new MyPattern(this.tokens, str).match()
  }
}
```

## 参考

- https://segmentfault.com/a/1190000021787021
- https://cloud.baidu.com/article/3288942
- https://nxtech.gitbook.io/regexp/advanced/dfa-nfa
- [实现一个基于 dfs 算法的简单正则表达式引擎](https://github.com/lizzz0523/language/blob/master/javascript/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Edfs%E7%AE%97%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%95%E6%93%8E.md)
