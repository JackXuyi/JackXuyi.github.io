---
title: 滚动加载更多
date: 2020-07-25 15:29:30
tags: node
---

当页面数据过多为了优化页面加载速度和避免页面的卡顿时使用滚动加载的方式实现数据的分页加载功能

### 加载更多方案

#### 利用 scroll 事件实现

通过监听对应元素的滚动，不断计算元素相对窗口的位置判断元素是否滚动到底部，若滚动到底部就加载更多

##### 缺点

- `scroll` 事件不断触发需要做节流操作实现
- 每次触发事件时都要计算元素的位置性能不好

##### 优点

- 兼容性好
- 易于实现

#### 利用 `IntersectionObserver` 实现

`IntersectionObserver`接口 (从属于`Intersection Observer API`) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(`viewport`)交叉状态的方法。

##### 优点

- `IntersectionObserver` 是浏览器内部实现的方法，性能较高
- 可以自定义视窗重叠的阈值

##### 缺点

- 兼容性较差

### 在 `React` 中的实现

- 初始化 `IntersectionObserver`，确定视窗窗口和触发阈值及回调函数
- 通过 `children` 属性获取子组件中的最后一个元素
- 监听列表中的最后一个组件，当最后的组件触发事件时加载更多
- 引入 `intersection-observer` 组件做兼容性处理

#### 完整代码参考

```tsx
import React from 'react'
import 'intersection-observer'

interface IProps extends React.DOMAttributes<HTMLDivElement> {
  children: any
  getRootElement?: (parent: Element) => Element
  rootMargin?: string
  observerCallback?: IntersectionObserverCallback
}

class LoadMore extends React.PureComponent<IProps> {
  private ele: Element | null = null
  private observer: IntersectionObserver | undefined
  private observerElement: Element | null = null
  private lastThreshold: number = 0

  public componentDidMount() {
    const { rootMargin } = this.props
    this.observer = new IntersectionObserver(this.observerCallback, {
      root: this.getRootElement(),
      rootMargin,
      threshold: [0, 0.01],
    })
    this.listenLastDom()
  }

  public componentDidUpdate(prevProps: IProps) {
    const { children: oldChildren } = prevProps
    const { children } = this.props
    const len = React.Children.toArray(children).length
    if (len !== React.Children.toArray(oldChildren).length && len) {
      this.listenLastDom()
    }
  }

  public componentWillUnmount() {
    this.unobserve()
  }

  public render() {
    const {
      children,
      getRootElement,
      observerCallback,
      rootMargin,
      ...otherProps
    } = this.props
    return (
      <div ref={this.getElement} {...otherProps}>
        {children}
      </div>
    )
  }

  private getRootElement = () => {
    const { getRootElement } = this.props
    const ele = this.ele as Element
    let parent = null
    if (getRootElement) {
      parent = getRootElement(
        ele && ele.parentElement
          ? ele.parentElement
          : (document.body as Element)
      )
    }
    if (!parent && ele && ele.parentElement) {
      parent = ele.parentElement
    }
    return parent
  }

  private getElement = (ele: Element | null) => {
    this.ele = ele
  }

  // 监听回调
  private observerCallback = (
    entries: IntersectionObserverEntry[],
    observer: IntersectionObserver
  ) => {
    const [{ intersectionRatio = 0 }] = entries

    const { observerCallback } = this.props
    if (intersectionRatio > this.lastThreshold) {
      if (observerCallback) {
        observerCallback(entries, observer)
      }
    }
    this.lastThreshold = intersectionRatio
  }

  // 停止监听元素
  private unobserve = () => {
    if (this.observerElement && this.observer) {
      this.observer.unobserve(this.observerElement)
    }
  }

  // 监听元素
  private listenLastDom = () => {
    if (this.ele && this.ele.lastChild) {
      const dom: Element = this.ele.lastChild as Element
      this.lastThreshold = 0
      const observer = this.observer as IntersectionObserver
      if (dom && observer) {
        this.unobserve()
        this.observerElement = dom
        observer.observe(this.observerElement)
      }
    }
  }
}

export default LoadMore
```

### 参考

- [IntersectionObserver](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver)
- [intersection-observer](https://www.npmjs.com/package/intersection-observer)
