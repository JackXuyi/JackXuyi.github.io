{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/tcp_close.png","path":"images/tcp_close.png","modified":1,"renderable":0},{"_id":"source/images/tcp_open.png","path":"images/tcp_open.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/0001.jpg","path":"0001.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"0bcc406417cc0d9b74fa7b4a64c068b33459f0df","modified":1521162898216},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1521162898224},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1521162898225},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1521162898246},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1521162898226},{"_id":"source/images/tcp_close.png","hash":"226b9cad4c9db7c3156b2b012ebfb9a2ecca1300","modified":1521162898223},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1521162898225},{"_id":"themes/landscape/_config.yml","hash":"2b992660f4112ef31c457b478a72d3502e2b2147","modified":1521162898227},{"_id":"source/_posts/TCP链接的建立与释放.md","hash":"97337af419157b14a39107ae1270566c5c9ac8de","modified":1521162898217},{"_id":"source/_posts/JavaScript的使用建议.md","hash":"6f8f34bf21dc2e704fbd5a07bc5b8cb276a54889","modified":1521162898217},{"_id":"source/_posts/hello-world.md","hash":"c7ac67b6cdddae9b4c5b721016274cab6ec05742","modified":1521162898218},{"_id":"source/_posts/memcpy函数的实现.md","hash":"28e902cbeab634d8ca7fe567d883f5a385675f45","modified":1521162898219},{"_id":"source/_posts/js学习（一）.md","hash":"cababed189697047fb9c314717c99122dcfa09b4","modified":1521162898218},{"_id":"source/_posts/source01.md","hash":"71a6672dbdf4c26a19866a7ac239d6cb8243a80c","modified":1521162898220},{"_id":"source/_posts/strcpy的实现.md","hash":"a8c0b58900968332a7aee1a6598815799cd2048a","modified":1521162898220},{"_id":"source/_posts/运算符重载.md","hash":"2350361de978015f405846d3ba0ee241e3de6aa0","modified":1521162898221},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1521162898227},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1521162898228},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1521162898228},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1521162898229},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1521162898229},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1521162898230},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1521162898230},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1521162898243},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1521162898244},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1521162898244},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1521162898243},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1521162898245},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1521162898245},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1521162898247},{"_id":"source/images/tcp_open.png","hash":"506b54bbb06b3d8f08e67549bac6fa10acce326d","modified":1521162898223},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1521162898246},{"_id":"themes/landscape/source/0001.jpg","hash":"f5cae53f2c577d2069215cff7b9d401aad5abe7a","modified":1521162898248},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1521162898231},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1521162898232},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1521162898234},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1521162898233},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1521162898234},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1521162898235},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1521162898236},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1521162898237},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1521162898240},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1521162898241},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1521162898242},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1521162898241},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1521162898242},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1521162898242},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1521162898249},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1521162898265},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1521162898264},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1521162898256},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1521162898265},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1521162898267},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1521162898267},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1521162898266},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1521162898272},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1521162898268},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1521162898271},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1521162898236},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1521162898273},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1521162898273},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1521162898238},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1521162898237},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1521162898238},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1521162898239},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1521162898239},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1521162898252},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1521162898250},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1521162898240},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1521162898252},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1521162898250},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1521162898251},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1521162898253},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1521162898253},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1521162898254},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1521162898258},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1521162898255},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1521162898258},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1521162898254},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1521162898254},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1521162898261},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1521162898256},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1521162898268},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1521162898269},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1521162898270},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1521162898269},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1521162898260},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1521162898270},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1521162898271},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1521162898260},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1521162898263}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"TCP链接的建立与释放","date":"2016-11-27T16:07:50.000Z","_content":"\n## TCP链接的建立（三次握手）\n\n假设主机A运行的是TCP客户端程序，而主机B运行的是TCP服务器端程序。最初两端的TCP链接都处于CLOSED状态。\n\n![TCP链接建立完整示意图](/images/tcp_open.png)\n\n+ B的TCP服务器进程先创建传输控制快TCB，准备接受客户进程的链接请求。然后处于LISTEN（收听）状态，等待客户的链接请求。如有，作出响应。\n+ A的TCP客户进程也是首先创建传输控制块TCB，然后向B发出链接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序列号seq=x。TCP客户端进入SYN-SENT（同步已发送）状态。\n+ B收到链接请求报文段后，如果同意建立链接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置为1,确认号为ack=x+1，同时选择一个初始序列号seq=y。TCP服务端处于SYN-RCVD（同步收到）状态。\n+ TCP客户端收到B的确认后，还要向B给出确认。确认报文段的ACK置1,确认号ack=y+1，而自己的序号为seq=x+1。这时，TCP链接已经建立，A进入ESTABLISHED（已建立链接）状态。\n+ 当B收到A的确认后，也进入ESTABLISHED状态。\n\n##### 注：TCP规定，SYN报文段（即SYN=1的报文段）不能携带数据，但是要消耗掉一个序号；ACK报文段可以携带数据，如果不携带数据则不消耗序号。\n\n\n## TCP链接的释放（四次挥手）\n\n数据传输结束后，传输双方都有可能释放链接。现在A和B都处于ESTABLISHED的状态。\n\n![TCP链接释放完整示意图](/images/tcp_close.png)\n\n+ A的应用进程先向其TCP链接发出链接释放报文段，并停止再发送数据，主动关闭TCP链接。A把链接释放报文段首部的终止控制位FIN置1,其序号seq=u，它等于前面已传送过的数据的最后一个字节的序号加1。A处于FIN-WAIT-1（终止等待1）状态，等待B的确认。\n+ B收到链接释放报文段后即发出确认，确认号是ack=u+1，自己序号为v，等于前面已经传送的最后一个字节的序号加1.B进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程这时应该通知高层应用进程，因而从A到B这个方向的链接就释放了，这时的TCP链接处于半关闭状态。\n+ A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的链接释放报文段。\n+ 若B已经没有要向A发送的数据，其应用就通知TCP释放链接。这时B发出的链接释放报文段必须使FIN=1。现假定B的序号w（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认号ack=u+1。B进入LAST-ACK（最后确认）状态，等待A的确认。\n+ A在收到B的链接释放报文后，必须对此发出确认。在确认报文中把ACK置1,确认号ack=w+1，而自己的序号为seq=u+1。然后进入到TIME-WAIT（时间等待）状态，等待2ms后进入到CLOSED状态。\n\n###### 注：TCP规定，FIN报文段即使不携带数据也要消耗一个序号。\n\n\n\n\n\n","source":"_posts/TCP链接的建立与释放.md","raw":"---\ntitle: TCP链接的建立与释放\ndate: 2016-11-27 16:07:50\ntags: 计算机网络\n---\n\n## TCP链接的建立（三次握手）\n\n假设主机A运行的是TCP客户端程序，而主机B运行的是TCP服务器端程序。最初两端的TCP链接都处于CLOSED状态。\n\n![TCP链接建立完整示意图](/images/tcp_open.png)\n\n+ B的TCP服务器进程先创建传输控制快TCB，准备接受客户进程的链接请求。然后处于LISTEN（收听）状态，等待客户的链接请求。如有，作出响应。\n+ A的TCP客户进程也是首先创建传输控制块TCB，然后向B发出链接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序列号seq=x。TCP客户端进入SYN-SENT（同步已发送）状态。\n+ B收到链接请求报文段后，如果同意建立链接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置为1,确认号为ack=x+1，同时选择一个初始序列号seq=y。TCP服务端处于SYN-RCVD（同步收到）状态。\n+ TCP客户端收到B的确认后，还要向B给出确认。确认报文段的ACK置1,确认号ack=y+1，而自己的序号为seq=x+1。这时，TCP链接已经建立，A进入ESTABLISHED（已建立链接）状态。\n+ 当B收到A的确认后，也进入ESTABLISHED状态。\n\n##### 注：TCP规定，SYN报文段（即SYN=1的报文段）不能携带数据，但是要消耗掉一个序号；ACK报文段可以携带数据，如果不携带数据则不消耗序号。\n\n\n## TCP链接的释放（四次挥手）\n\n数据传输结束后，传输双方都有可能释放链接。现在A和B都处于ESTABLISHED的状态。\n\n![TCP链接释放完整示意图](/images/tcp_close.png)\n\n+ A的应用进程先向其TCP链接发出链接释放报文段，并停止再发送数据，主动关闭TCP链接。A把链接释放报文段首部的终止控制位FIN置1,其序号seq=u，它等于前面已传送过的数据的最后一个字节的序号加1。A处于FIN-WAIT-1（终止等待1）状态，等待B的确认。\n+ B收到链接释放报文段后即发出确认，确认号是ack=u+1，自己序号为v，等于前面已经传送的最后一个字节的序号加1.B进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程这时应该通知高层应用进程，因而从A到B这个方向的链接就释放了，这时的TCP链接处于半关闭状态。\n+ A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的链接释放报文段。\n+ 若B已经没有要向A发送的数据，其应用就通知TCP释放链接。这时B发出的链接释放报文段必须使FIN=1。现假定B的序号w（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认号ack=u+1。B进入LAST-ACK（最后确认）状态，等待A的确认。\n+ A在收到B的链接释放报文后，必须对此发出确认。在确认报文中把ACK置1,确认号ack=w+1，而自己的序号为seq=u+1。然后进入到TIME-WAIT（时间等待）状态，等待2ms后进入到CLOSED状态。\n\n###### 注：TCP规定，FIN报文段即使不携带数据也要消耗一个序号。\n\n\n\n\n\n","slug":"TCP链接的建立与释放","published":1,"updated":"2018-03-16T01:14:58.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjet9hysm00001kb1f17r77nb","content":"<h2 id=\"TCP链接的建立（三次握手）\"><a href=\"#TCP链接的建立（三次握手）\" class=\"headerlink\" title=\"TCP链接的建立（三次握手）\"></a>TCP链接的建立（三次握手）</h2><p>假设主机A运行的是TCP客户端程序，而主机B运行的是TCP服务器端程序。最初两端的TCP链接都处于CLOSED状态。</p>\n<p><img src=\"/images/tcp_open.png\" alt=\"TCP链接建立完整示意图\"></p>\n<ul>\n<li>B的TCP服务器进程先创建传输控制快TCB，准备接受客户进程的链接请求。然后处于LISTEN（收听）状态，等待客户的链接请求。如有，作出响应。</li>\n<li>A的TCP客户进程也是首先创建传输控制块TCB，然后向B发出链接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序列号seq=x。TCP客户端进入SYN-SENT（同步已发送）状态。</li>\n<li>B收到链接请求报文段后，如果同意建立链接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置为1,确认号为ack=x+1，同时选择一个初始序列号seq=y。TCP服务端处于SYN-RCVD（同步收到）状态。</li>\n<li>TCP客户端收到B的确认后，还要向B给出确认。确认报文段的ACK置1,确认号ack=y+1，而自己的序号为seq=x+1。这时，TCP链接已经建立，A进入ESTABLISHED（已建立链接）状态。</li>\n<li>当B收到A的确认后，也进入ESTABLISHED状态。</li>\n</ul>\n<h5 id=\"注：TCP规定，SYN报文段（即SYN-1的报文段）不能携带数据，但是要消耗掉一个序号；ACK报文段可以携带数据，如果不携带数据则不消耗序号。\"><a href=\"#注：TCP规定，SYN报文段（即SYN-1的报文段）不能携带数据，但是要消耗掉一个序号；ACK报文段可以携带数据，如果不携带数据则不消耗序号。\" class=\"headerlink\" title=\"注：TCP规定，SYN报文段（即SYN=1的报文段）不能携带数据，但是要消耗掉一个序号；ACK报文段可以携带数据，如果不携带数据则不消耗序号。\"></a>注：TCP规定，SYN报文段（即SYN=1的报文段）不能携带数据，但是要消耗掉一个序号；ACK报文段可以携带数据，如果不携带数据则不消耗序号。</h5><h2 id=\"TCP链接的释放（四次挥手）\"><a href=\"#TCP链接的释放（四次挥手）\" class=\"headerlink\" title=\"TCP链接的释放（四次挥手）\"></a>TCP链接的释放（四次挥手）</h2><p>数据传输结束后，传输双方都有可能释放链接。现在A和B都处于ESTABLISHED的状态。</p>\n<p><img src=\"/images/tcp_close.png\" alt=\"TCP链接释放完整示意图\"></p>\n<ul>\n<li>A的应用进程先向其TCP链接发出链接释放报文段，并停止再发送数据，主动关闭TCP链接。A把链接释放报文段首部的终止控制位FIN置1,其序号seq=u，它等于前面已传送过的数据的最后一个字节的序号加1。A处于FIN-WAIT-1（终止等待1）状态，等待B的确认。</li>\n<li>B收到链接释放报文段后即发出确认，确认号是ack=u+1，自己序号为v，等于前面已经传送的最后一个字节的序号加1.B进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程这时应该通知高层应用进程，因而从A到B这个方向的链接就释放了，这时的TCP链接处于半关闭状态。</li>\n<li>A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的链接释放报文段。</li>\n<li>若B已经没有要向A发送的数据，其应用就通知TCP释放链接。这时B发出的链接释放报文段必须使FIN=1。现假定B的序号w（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认号ack=u+1。B进入LAST-ACK（最后确认）状态，等待A的确认。</li>\n<li>A在收到B的链接释放报文后，必须对此发出确认。在确认报文中把ACK置1,确认号ack=w+1，而自己的序号为seq=u+1。然后进入到TIME-WAIT（时间等待）状态，等待2ms后进入到CLOSED状态。</li>\n</ul>\n<h6 id=\"注：TCP规定，FIN报文段即使不携带数据也要消耗一个序号。\"><a href=\"#注：TCP规定，FIN报文段即使不携带数据也要消耗一个序号。\" class=\"headerlink\" title=\"注：TCP规定，FIN报文段即使不携带数据也要消耗一个序号。\"></a>注：TCP规定，FIN报文段即使不携带数据也要消耗一个序号。</h6>","excerpt":"","more":"<h2 id=\"TCP链接的建立（三次握手）\"><a href=\"#TCP链接的建立（三次握手）\" class=\"headerlink\" title=\"TCP链接的建立（三次握手）\"></a>TCP链接的建立（三次握手）</h2><p>假设主机A运行的是TCP客户端程序，而主机B运行的是TCP服务器端程序。最初两端的TCP链接都处于CLOSED状态。</p>\n<p><img src=\"/images/tcp_open.png\" alt=\"TCP链接建立完整示意图\"></p>\n<ul>\n<li>B的TCP服务器进程先创建传输控制快TCB，准备接受客户进程的链接请求。然后处于LISTEN（收听）状态，等待客户的链接请求。如有，作出响应。</li>\n<li>A的TCP客户进程也是首先创建传输控制块TCB，然后向B发出链接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序列号seq=x。TCP客户端进入SYN-SENT（同步已发送）状态。</li>\n<li>B收到链接请求报文段后，如果同意建立链接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置为1,确认号为ack=x+1，同时选择一个初始序列号seq=y。TCP服务端处于SYN-RCVD（同步收到）状态。</li>\n<li>TCP客户端收到B的确认后，还要向B给出确认。确认报文段的ACK置1,确认号ack=y+1，而自己的序号为seq=x+1。这时，TCP链接已经建立，A进入ESTABLISHED（已建立链接）状态。</li>\n<li>当B收到A的确认后，也进入ESTABLISHED状态。</li>\n</ul>\n<h5 id=\"注：TCP规定，SYN报文段（即SYN-1的报文段）不能携带数据，但是要消耗掉一个序号；ACK报文段可以携带数据，如果不携带数据则不消耗序号。\"><a href=\"#注：TCP规定，SYN报文段（即SYN-1的报文段）不能携带数据，但是要消耗掉一个序号；ACK报文段可以携带数据，如果不携带数据则不消耗序号。\" class=\"headerlink\" title=\"注：TCP规定，SYN报文段（即SYN=1的报文段）不能携带数据，但是要消耗掉一个序号；ACK报文段可以携带数据，如果不携带数据则不消耗序号。\"></a>注：TCP规定，SYN报文段（即SYN=1的报文段）不能携带数据，但是要消耗掉一个序号；ACK报文段可以携带数据，如果不携带数据则不消耗序号。</h5><h2 id=\"TCP链接的释放（四次挥手）\"><a href=\"#TCP链接的释放（四次挥手）\" class=\"headerlink\" title=\"TCP链接的释放（四次挥手）\"></a>TCP链接的释放（四次挥手）</h2><p>数据传输结束后，传输双方都有可能释放链接。现在A和B都处于ESTABLISHED的状态。</p>\n<p><img src=\"/images/tcp_close.png\" alt=\"TCP链接释放完整示意图\"></p>\n<ul>\n<li>A的应用进程先向其TCP链接发出链接释放报文段，并停止再发送数据，主动关闭TCP链接。A把链接释放报文段首部的终止控制位FIN置1,其序号seq=u，它等于前面已传送过的数据的最后一个字节的序号加1。A处于FIN-WAIT-1（终止等待1）状态，等待B的确认。</li>\n<li>B收到链接释放报文段后即发出确认，确认号是ack=u+1，自己序号为v，等于前面已经传送的最后一个字节的序号加1.B进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程这时应该通知高层应用进程，因而从A到B这个方向的链接就释放了，这时的TCP链接处于半关闭状态。</li>\n<li>A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的链接释放报文段。</li>\n<li>若B已经没有要向A发送的数据，其应用就通知TCP释放链接。这时B发出的链接释放报文段必须使FIN=1。现假定B的序号w（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认号ack=u+1。B进入LAST-ACK（最后确认）状态，等待A的确认。</li>\n<li>A在收到B的链接释放报文后，必须对此发出确认。在确认报文中把ACK置1,确认号ack=w+1，而自己的序号为seq=u+1。然后进入到TIME-WAIT（时间等待）状态，等待2ms后进入到CLOSED状态。</li>\n</ul>\n<h6 id=\"注：TCP规定，FIN报文段即使不携带数据也要消耗一个序号。\"><a href=\"#注：TCP规定，FIN报文段即使不携带数据也要消耗一个序号。\" class=\"headerlink\" title=\"注：TCP规定，FIN报文段即使不携带数据也要消耗一个序号。\"></a>注：TCP规定，FIN报文段即使不携带数据也要消耗一个序号。</h6>"},{"title":"JavaScript的使用建议","date":"2017-09-24T17:23:03.000Z","_content":"\n## JavaScript的使用建议\n\n1. 使用`===`代替`==`，`==`和`!=`会强制转换类型。\n2. 避免使用`eval`，`eval`不仅降低脚本的性能，而且由于需要的权限比较高会造成安全风险。\n3. 不要省略`{}`，即使代码快只有一行也不可以，便于以后的阅读和修改。\n4. 使用`JSLint`检查代码是否存在错误。\n5. 把js脚本嵌在文件的底部。\n6. 避免在`for`语句中声明变量。\n7. 使用数组或者对象构建字符串时使用`join`方法。\n8. 脚本中减少全局变量的使用，建议用对象把方法和属性包裹起来。\n9. 给代码添加注释。\n10. 在没有启用`js`的情况下逐步增强网站效果。\n11. `setInterval`和`setTimeout`不要传递字符串参数而是使用函数名称。\n12. 不要使用`with`语句。\n13. 使用`{}`代替`new Object()`。\n14. 使用`[]`代替`new Array()`。\n15. 定义多个变量时，省略关键字`let`、`var`等，用逗号代替。\n16. 不要省略分号。\n17. `for in`使用判断条件过滤信息避免多余的循环次数以提高性能。\n18. 通过计算运行时间优化代码。\n19. 多阅读。\n20. 自执行函数，用`(函数实现)(函数参数);`实现自执行函数。\n21. 移除`script`标签中的`language`属性。\n","source":"_posts/JavaScript的使用建议.md","raw":"---\ntitle: JavaScript的使用建议\ndate: 2017-09-24 17:23:03\ntags: JavaScript\n---\n\n## JavaScript的使用建议\n\n1. 使用`===`代替`==`，`==`和`!=`会强制转换类型。\n2. 避免使用`eval`，`eval`不仅降低脚本的性能，而且由于需要的权限比较高会造成安全风险。\n3. 不要省略`{}`，即使代码快只有一行也不可以，便于以后的阅读和修改。\n4. 使用`JSLint`检查代码是否存在错误。\n5. 把js脚本嵌在文件的底部。\n6. 避免在`for`语句中声明变量。\n7. 使用数组或者对象构建字符串时使用`join`方法。\n8. 脚本中减少全局变量的使用，建议用对象把方法和属性包裹起来。\n9. 给代码添加注释。\n10. 在没有启用`js`的情况下逐步增强网站效果。\n11. `setInterval`和`setTimeout`不要传递字符串参数而是使用函数名称。\n12. 不要使用`with`语句。\n13. 使用`{}`代替`new Object()`。\n14. 使用`[]`代替`new Array()`。\n15. 定义多个变量时，省略关键字`let`、`var`等，用逗号代替。\n16. 不要省略分号。\n17. `for in`使用判断条件过滤信息避免多余的循环次数以提高性能。\n18. 通过计算运行时间优化代码。\n19. 多阅读。\n20. 自执行函数，用`(函数实现)(函数参数);`实现自执行函数。\n21. 移除`script`标签中的`language`属性。\n","slug":"JavaScript的使用建议","published":1,"updated":"2018-03-16T01:14:58.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjet9hysp00011kb1rj6j23xd","content":"<h2 id=\"JavaScript的使用建议\"><a href=\"#JavaScript的使用建议\" class=\"headerlink\" title=\"JavaScript的使用建议\"></a>JavaScript的使用建议</h2><ol>\n<li>使用<code>===</code>代替<code>==</code>，<code>==</code>和<code>!=</code>会强制转换类型。</li>\n<li>避免使用<code>eval</code>，<code>eval</code>不仅降低脚本的性能，而且由于需要的权限比较高会造成安全风险。</li>\n<li>不要省略<code>{}</code>，即使代码快只有一行也不可以，便于以后的阅读和修改。</li>\n<li>使用<code>JSLint</code>检查代码是否存在错误。</li>\n<li>把js脚本嵌在文件的底部。</li>\n<li>避免在<code>for</code>语句中声明变量。</li>\n<li>使用数组或者对象构建字符串时使用<code>join</code>方法。</li>\n<li>脚本中减少全局变量的使用，建议用对象把方法和属性包裹起来。</li>\n<li>给代码添加注释。</li>\n<li>在没有启用<code>js</code>的情况下逐步增强网站效果。</li>\n<li><code>setInterval</code>和<code>setTimeout</code>不要传递字符串参数而是使用函数名称。</li>\n<li>不要使用<code>with</code>语句。</li>\n<li>使用<code>{}</code>代替<code>new Object()</code>。</li>\n<li>使用<code>[]</code>代替<code>new Array()</code>。</li>\n<li>定义多个变量时，省略关键字<code>let</code>、<code>var</code>等，用逗号代替。</li>\n<li>不要省略分号。</li>\n<li><code>for in</code>使用判断条件过滤信息避免多余的循环次数以提高性能。</li>\n<li>通过计算运行时间优化代码。</li>\n<li>多阅读。</li>\n<li>自执行函数，用<code>(函数实现)(函数参数);</code>实现自执行函数。</li>\n<li>移除<code>script</code>标签中的<code>language</code>属性。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"JavaScript的使用建议\"><a href=\"#JavaScript的使用建议\" class=\"headerlink\" title=\"JavaScript的使用建议\"></a>JavaScript的使用建议</h2><ol>\n<li>使用<code>===</code>代替<code>==</code>，<code>==</code>和<code>!=</code>会强制转换类型。</li>\n<li>避免使用<code>eval</code>，<code>eval</code>不仅降低脚本的性能，而且由于需要的权限比较高会造成安全风险。</li>\n<li>不要省略<code>{}</code>，即使代码快只有一行也不可以，便于以后的阅读和修改。</li>\n<li>使用<code>JSLint</code>检查代码是否存在错误。</li>\n<li>把js脚本嵌在文件的底部。</li>\n<li>避免在<code>for</code>语句中声明变量。</li>\n<li>使用数组或者对象构建字符串时使用<code>join</code>方法。</li>\n<li>脚本中减少全局变量的使用，建议用对象把方法和属性包裹起来。</li>\n<li>给代码添加注释。</li>\n<li>在没有启用<code>js</code>的情况下逐步增强网站效果。</li>\n<li><code>setInterval</code>和<code>setTimeout</code>不要传递字符串参数而是使用函数名称。</li>\n<li>不要使用<code>with</code>语句。</li>\n<li>使用<code>{}</code>代替<code>new Object()</code>。</li>\n<li>使用<code>[]</code>代替<code>new Array()</code>。</li>\n<li>定义多个变量时，省略关键字<code>let</code>、<code>var</code>等，用逗号代替。</li>\n<li>不要省略分号。</li>\n<li><code>for in</code>使用判断条件过滤信息避免多余的循环次数以提高性能。</li>\n<li>通过计算运行时间优化代码。</li>\n<li>多阅读。</li>\n<li>自执行函数，用<code>(函数实现)(函数参数);</code>实现自执行函数。</li>\n<li>移除<code>script</code>标签中的<code>language</code>属性。</li>\n</ol>\n"},{"title":"用Hexo搭建静态博客","_content":"\n## 环境准备\n\n+ Git安装及使用：[廖雪峰的网站](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n+ Node.js的安装：[Node.js 安装配置](http://www.runoob.com/nodejs/nodejs-install-setup.html)\n+ Hexo的安装及使用：[Hexo文档](https://hexo.io/zh-cn/docs/index.html)\n+ yilia主题的安装配置：[yilia简介、安装、配置](https://github.com/litten/hexo-theme-yilia)\n\n## hexo环境配置\n\n- 创建文件夹 blog 作为项目文件夹\n- 初始化项目文件夹\n\n+ 指定文件夹初始化\n\n\t\thexo init blog\n\n+ 或者，进入文件夹再初始化\n\n\t\tcd blog \n\t\thexo init\n\n- 安装插件 deployer \n\n\t\tnpm install hexo-deployer-git --save\n\n- 修改根目录下的 _config.yml 文件\n\t\n\t\tdeploy:\n\t\ttype: git\n\t\trepo: git@github.com:JackXuyi/JackXuyi.github.io.git\n\t\tbranch: master\n\n- 配置域名：在 source 目录下添加 CNAME 文件，并在文件里写入你的域名\n\n\t\txuyi-emb.win\n\n## 使用说明\n\n* 源代码和发布的网站的存储位置不在同一个地方，使用不同分支保存数据，具体解释见 [使用hexo，如果换了电脑怎么更新博客？](http://www.zhihu.com/question/21193762)\n","source":"_posts/hello-world.md","raw":"---\ntitle: 用Hexo搭建静态博客\ntags: 其它\n---\n\n## 环境准备\n\n+ Git安装及使用：[廖雪峰的网站](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n+ Node.js的安装：[Node.js 安装配置](http://www.runoob.com/nodejs/nodejs-install-setup.html)\n+ Hexo的安装及使用：[Hexo文档](https://hexo.io/zh-cn/docs/index.html)\n+ yilia主题的安装配置：[yilia简介、安装、配置](https://github.com/litten/hexo-theme-yilia)\n\n## hexo环境配置\n\n- 创建文件夹 blog 作为项目文件夹\n- 初始化项目文件夹\n\n+ 指定文件夹初始化\n\n\t\thexo init blog\n\n+ 或者，进入文件夹再初始化\n\n\t\tcd blog \n\t\thexo init\n\n- 安装插件 deployer \n\n\t\tnpm install hexo-deployer-git --save\n\n- 修改根目录下的 _config.yml 文件\n\t\n\t\tdeploy:\n\t\ttype: git\n\t\trepo: git@github.com:JackXuyi/JackXuyi.github.io.git\n\t\tbranch: master\n\n- 配置域名：在 source 目录下添加 CNAME 文件，并在文件里写入你的域名\n\n\t\txuyi-emb.win\n\n## 使用说明\n\n* 源代码和发布的网站的存储位置不在同一个地方，使用不同分支保存数据，具体解释见 [使用hexo，如果换了电脑怎么更新博客？](http://www.zhihu.com/question/21193762)\n","slug":"hello-world","published":1,"date":"2018-03-16T01:14:58.217Z","updated":"2018-03-16T01:14:58.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjet9hyst00031kb1uec1pnuv","content":"<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ul>\n<li>Git安装及使用：<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"external\">廖雪峰的网站</a></li>\n<li>Node.js的安装：<a href=\"http://www.runoob.com/nodejs/nodejs-install-setup.html\" target=\"_blank\" rel=\"external\">Node.js 安装配置</a></li>\n<li>Hexo的安装及使用：<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"external\">Hexo文档</a></li>\n<li>yilia主题的安装配置：<a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"external\">yilia简介、安装、配置</a></li>\n</ul>\n<h2 id=\"hexo环境配置\"><a href=\"#hexo环境配置\" class=\"headerlink\" title=\"hexo环境配置\"></a>hexo环境配置</h2><ul>\n<li>创建文件夹 blog 作为项目文件夹</li>\n<li>初始化项目文件夹</li>\n</ul>\n<ul>\n<li><p>指定文件夹初始化</p>\n<pre><code>hexo init blog\n</code></pre></li>\n<li><p>或者，进入文件夹再初始化</p>\n<pre><code>cd blog \nhexo init\n</code></pre></li>\n</ul>\n<ul>\n<li><p>安装插件 deployer </p>\n<pre><code>npm install hexo-deployer-git --save\n</code></pre></li>\n<li><p>修改根目录下的 _config.yml 文件</p>\n<pre><code>deploy:\ntype: git\nrepo: git@github.com:JackXuyi/JackXuyi.github.io.git\nbranch: master\n</code></pre></li>\n<li><p>配置域名：在 source 目录下添加 CNAME 文件，并在文件里写入你的域名</p>\n<pre><code>xuyi-emb.win\n</code></pre></li>\n</ul>\n<h2 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><ul>\n<li>源代码和发布的网站的存储位置不在同一个地方，使用不同分支保存数据，具体解释见 <a href=\"http://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"external\">使用hexo，如果换了电脑怎么更新博客？</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ul>\n<li>Git安装及使用：<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\">廖雪峰的网站</a></li>\n<li>Node.js的安装：<a href=\"http://www.runoob.com/nodejs/nodejs-install-setup.html\">Node.js 安装配置</a></li>\n<li>Hexo的安装及使用：<a href=\"https://hexo.io/zh-cn/docs/index.html\">Hexo文档</a></li>\n<li>yilia主题的安装配置：<a href=\"https://github.com/litten/hexo-theme-yilia\">yilia简介、安装、配置</a></li>\n</ul>\n<h2 id=\"hexo环境配置\"><a href=\"#hexo环境配置\" class=\"headerlink\" title=\"hexo环境配置\"></a>hexo环境配置</h2><ul>\n<li>创建文件夹 blog 作为项目文件夹</li>\n<li>初始化项目文件夹</li>\n</ul>\n<ul>\n<li><p>指定文件夹初始化</p>\n<pre><code>hexo init blog\n</code></pre></li>\n<li><p>或者，进入文件夹再初始化</p>\n<pre><code>cd blog \nhexo init\n</code></pre></li>\n</ul>\n<ul>\n<li><p>安装插件 deployer </p>\n<pre><code>npm install hexo-deployer-git --save\n</code></pre></li>\n<li><p>修改根目录下的 _config.yml 文件</p>\n<pre><code>deploy:\ntype: git\nrepo: git@github.com:JackXuyi/JackXuyi.github.io.git\nbranch: master\n</code></pre></li>\n<li><p>配置域名：在 source 目录下添加 CNAME 文件，并在文件里写入你的域名</p>\n<pre><code>xuyi-emb.win\n</code></pre></li>\n</ul>\n<h2 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><ul>\n<li>源代码和发布的网站的存储位置不在同一个地方，使用不同分支保存数据，具体解释见 <a href=\"http://www.zhihu.com/question/21193762\">使用hexo，如果换了电脑怎么更新博客？</a></li>\n</ul>\n"},{"title":"memcpy函数的实现","date":"2016-11-28T22:55:25.000Z","_content":"\n## memcpy的代码实现\n\n\tvoid * memcpy(void *dest, const void *src, size_t count)\n\t{ \n    \t\tif (dest == NULL || src == NULL)//判断是否为空避免非法操作\n\t\t\treturn NULL; \n    \t\tchar *pdest = static_cast <char*>(dest);\n    \t\tconst char *psrc  = static_cast <const char*>(src); \n    \t\tint n = count; \n    \t\tif (pdest > psrc && pdest < psrc+count) //目的地址大于源地址且存在内存重叠\n    \t\t{ \n        \t\tfor (size_t i=n-1; i != -1; --i)//从高位开始复制避免出现字符覆盖的情况\n        \t\t{ \n            \t\t\t*(pdest+i) = *(psrc+i); \n        \t\t} \n    \t\t} \n    \t\telse\n    \t\t{ \n        \t\tfor (size_t i= 0; i < n; i++) //从低位开始复制\n        \t\t{ \n           \t\t\t*(pdest+i) = *(psrc+i);\n        \t\t} \n    \t\t}\n    \t\treturn dest; \n\t}\n\n##### 注：这里没有考虑内存重叠的所有情况\n\n","source":"_posts/memcpy函数的实现.md","raw":"---\ntitle: memcpy函数的实现\ndate: 2016-11-28 22:55:25\ntags: C/C++语言\n---\n\n## memcpy的代码实现\n\n\tvoid * memcpy(void *dest, const void *src, size_t count)\n\t{ \n    \t\tif (dest == NULL || src == NULL)//判断是否为空避免非法操作\n\t\t\treturn NULL; \n    \t\tchar *pdest = static_cast <char*>(dest);\n    \t\tconst char *psrc  = static_cast <const char*>(src); \n    \t\tint n = count; \n    \t\tif (pdest > psrc && pdest < psrc+count) //目的地址大于源地址且存在内存重叠\n    \t\t{ \n        \t\tfor (size_t i=n-1; i != -1; --i)//从高位开始复制避免出现字符覆盖的情况\n        \t\t{ \n            \t\t\t*(pdest+i) = *(psrc+i); \n        \t\t} \n    \t\t} \n    \t\telse\n    \t\t{ \n        \t\tfor (size_t i= 0; i < n; i++) //从低位开始复制\n        \t\t{ \n           \t\t\t*(pdest+i) = *(psrc+i);\n        \t\t} \n    \t\t}\n    \t\treturn dest; \n\t}\n\n##### 注：这里没有考虑内存重叠的所有情况\n\n","slug":"memcpy函数的实现","published":1,"updated":"2018-03-16T01:14:58.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjet9hysu00041kb11ulf4spy","content":"<h2 id=\"memcpy的代码实现\"><a href=\"#memcpy的代码实现\" class=\"headerlink\" title=\"memcpy的代码实现\"></a>memcpy的代码实现</h2><pre><code>void * memcpy(void *dest, const void *src, size_t count)\n{ \n        if (dest == NULL || src == NULL)//判断是否为空避免非法操作\n        return NULL; \n        char *pdest = static_cast &lt;char*&gt;(dest);\n        const char *psrc  = static_cast &lt;const char*&gt;(src); \n        int n = count; \n        if (pdest &gt; psrc &amp;&amp; pdest &lt; psrc+count) //目的地址大于源地址且存在内存重叠\n        { \n            for (size_t i=n-1; i != -1; --i)//从高位开始复制避免出现字符覆盖的情况\n            { \n                    *(pdest+i) = *(psrc+i); \n            } \n        } \n        else\n        { \n            for (size_t i= 0; i &lt; n; i++) //从低位开始复制\n            { \n                   *(pdest+i) = *(psrc+i);\n            } \n        }\n        return dest; \n}\n</code></pre><h5 id=\"注：这里没有考虑内存重叠的所有情况\"><a href=\"#注：这里没有考虑内存重叠的所有情况\" class=\"headerlink\" title=\"注：这里没有考虑内存重叠的所有情况\"></a>注：这里没有考虑内存重叠的所有情况</h5>","excerpt":"","more":"<h2 id=\"memcpy的代码实现\"><a href=\"#memcpy的代码实现\" class=\"headerlink\" title=\"memcpy的代码实现\"></a>memcpy的代码实现</h2><pre><code>void * memcpy(void *dest, const void *src, size_t count)\n{ \n        if (dest == NULL || src == NULL)//判断是否为空避免非法操作\n        return NULL; \n        char *pdest = static_cast &lt;char*&gt;(dest);\n        const char *psrc  = static_cast &lt;const char*&gt;(src); \n        int n = count; \n        if (pdest &gt; psrc &amp;&amp; pdest &lt; psrc+count) //目的地址大于源地址且存在内存重叠\n        { \n            for (size_t i=n-1; i != -1; --i)//从高位开始复制避免出现字符覆盖的情况\n            { \n                    *(pdest+i) = *(psrc+i); \n            } \n        } \n        else\n        { \n            for (size_t i= 0; i &lt; n; i++) //从低位开始复制\n            { \n                   *(pdest+i) = *(psrc+i);\n            } \n        }\n        return dest; \n}\n</code></pre><h5 id=\"注：这里没有考虑内存重叠的所有情况\"><a href=\"#注：这里没有考虑内存重叠的所有情况\" class=\"headerlink\" title=\"注：这里没有考虑内存重叠的所有情况\"></a>注：这里没有考虑内存重叠的所有情况</h5>"},{"title":"js学习（一）","date":"2017-09-22T21:59:32.000Z","_content":"\n## `setState`参数\n\n```\nvoid setState(\n      function|object nextState,\n      [function callback]\n    )\n```\n\n1. 第一个参数可以是一个函数也可以是一个对象，但是返回值都是下一个`state`的状态。\n2. 第二个参数为`setState`这个函数异步调用结束以后的回调函数，可以用在组件设置完`state`以后进行的操作。\n\n## `js`对网页滚动条的操作\n\n+ `js`可以通过改变目标元素的`scrollTop`改变元素滚动条的位置\n+ `onWheel`事件可以监听滚动条滚动事件，可以通过`deltaX`和`deltaY`属性获取滚动条滚动的位置和方向\n+ `onScroll`事件可以监听滚动条事件，但是无法获取方向和滚动距离及位置\n+ `CSS`中没有可以操作`scrollTop`值的属性\n\n## `setInterval`\n\n`setInterval`定时执行函数，当先后创建多个定时器时可能不会按照你预想的顺序来执行，因为`js`是单线程的，只有当前一个任务执行完毕以后才能够继续执行下一任务，所以调用定时器的时间可能大于你预设的时间，由此造成调用定时器的混乱。\n\n## js实现动画\n\n- 通过js中的定时器不断的改变元素的位置和高度模拟动画效果\n- 通过一个定时器管理函数管理定时器的先后调用顺序或者通过`dom2`级时间`removeEventLisenner`函数让元素在js调用定时器期间失去时间响应解决定时器无法顺序调用的各种问题\n","source":"_posts/js学习（一）.md","raw":"---\ntitle: js学习（一）\ndate: 2017-09-22 21:59:32\ntags: JavaScript\n---\n\n## `setState`参数\n\n```\nvoid setState(\n      function|object nextState,\n      [function callback]\n    )\n```\n\n1. 第一个参数可以是一个函数也可以是一个对象，但是返回值都是下一个`state`的状态。\n2. 第二个参数为`setState`这个函数异步调用结束以后的回调函数，可以用在组件设置完`state`以后进行的操作。\n\n## `js`对网页滚动条的操作\n\n+ `js`可以通过改变目标元素的`scrollTop`改变元素滚动条的位置\n+ `onWheel`事件可以监听滚动条滚动事件，可以通过`deltaX`和`deltaY`属性获取滚动条滚动的位置和方向\n+ `onScroll`事件可以监听滚动条事件，但是无法获取方向和滚动距离及位置\n+ `CSS`中没有可以操作`scrollTop`值的属性\n\n## `setInterval`\n\n`setInterval`定时执行函数，当先后创建多个定时器时可能不会按照你预想的顺序来执行，因为`js`是单线程的，只有当前一个任务执行完毕以后才能够继续执行下一任务，所以调用定时器的时间可能大于你预设的时间，由此造成调用定时器的混乱。\n\n## js实现动画\n\n- 通过js中的定时器不断的改变元素的位置和高度模拟动画效果\n- 通过一个定时器管理函数管理定时器的先后调用顺序或者通过`dom2`级时间`removeEventLisenner`函数让元素在js调用定时器期间失去时间响应解决定时器无法顺序调用的各种问题\n","slug":"js学习（一）","published":1,"updated":"2018-03-16T01:14:58.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjet9hysv00051kb1lwtktl1x","content":"<h2 id=\"setState参数\"><a href=\"#setState参数\" class=\"headerlink\" title=\"setState参数\"></a><code>setState</code>参数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">void setState(</div><div class=\"line\">      function|object nextState,</div><div class=\"line\">      [function callback]</div><div class=\"line\">    )</div></pre></td></tr></table></figure>\n<ol>\n<li>第一个参数可以是一个函数也可以是一个对象，但是返回值都是下一个<code>state</code>的状态。</li>\n<li>第二个参数为<code>setState</code>这个函数异步调用结束以后的回调函数，可以用在组件设置完<code>state</code>以后进行的操作。</li>\n</ol>\n<h2 id=\"js对网页滚动条的操作\"><a href=\"#js对网页滚动条的操作\" class=\"headerlink\" title=\"js对网页滚动条的操作\"></a><code>js</code>对网页滚动条的操作</h2><ul>\n<li><code>js</code>可以通过改变目标元素的<code>scrollTop</code>改变元素滚动条的位置</li>\n<li><code>onWheel</code>事件可以监听滚动条滚动事件，可以通过<code>deltaX</code>和<code>deltaY</code>属性获取滚动条滚动的位置和方向</li>\n<li><code>onScroll</code>事件可以监听滚动条事件，但是无法获取方向和滚动距离及位置</li>\n<li><code>CSS</code>中没有可以操作<code>scrollTop</code>值的属性</li>\n</ul>\n<h2 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a><code>setInterval</code></h2><p><code>setInterval</code>定时执行函数，当先后创建多个定时器时可能不会按照你预想的顺序来执行，因为<code>js</code>是单线程的，只有当前一个任务执行完毕以后才能够继续执行下一任务，所以调用定时器的时间可能大于你预设的时间，由此造成调用定时器的混乱。</p>\n<h2 id=\"js实现动画\"><a href=\"#js实现动画\" class=\"headerlink\" title=\"js实现动画\"></a>js实现动画</h2><ul>\n<li>通过js中的定时器不断的改变元素的位置和高度模拟动画效果</li>\n<li>通过一个定时器管理函数管理定时器的先后调用顺序或者通过<code>dom2</code>级时间<code>removeEventLisenner</code>函数让元素在js调用定时器期间失去时间响应解决定时器无法顺序调用的各种问题</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"setState参数\"><a href=\"#setState参数\" class=\"headerlink\" title=\"setState参数\"></a><code>setState</code>参数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">void setState(</div><div class=\"line\">      function|object nextState,</div><div class=\"line\">      [function callback]</div><div class=\"line\">    )</div></pre></td></tr></table></figure>\n<ol>\n<li>第一个参数可以是一个函数也可以是一个对象，但是返回值都是下一个<code>state</code>的状态。</li>\n<li>第二个参数为<code>setState</code>这个函数异步调用结束以后的回调函数，可以用在组件设置完<code>state</code>以后进行的操作。</li>\n</ol>\n<h2 id=\"js对网页滚动条的操作\"><a href=\"#js对网页滚动条的操作\" class=\"headerlink\" title=\"js对网页滚动条的操作\"></a><code>js</code>对网页滚动条的操作</h2><ul>\n<li><code>js</code>可以通过改变目标元素的<code>scrollTop</code>改变元素滚动条的位置</li>\n<li><code>onWheel</code>事件可以监听滚动条滚动事件，可以通过<code>deltaX</code>和<code>deltaY</code>属性获取滚动条滚动的位置和方向</li>\n<li><code>onScroll</code>事件可以监听滚动条事件，但是无法获取方向和滚动距离及位置</li>\n<li><code>CSS</code>中没有可以操作<code>scrollTop</code>值的属性</li>\n</ul>\n<h2 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a><code>setInterval</code></h2><p><code>setInterval</code>定时执行函数，当先后创建多个定时器时可能不会按照你预想的顺序来执行，因为<code>js</code>是单线程的，只有当前一个任务执行完毕以后才能够继续执行下一任务，所以调用定时器的时间可能大于你预设的时间，由此造成调用定时器的混乱。</p>\n<h2 id=\"js实现动画\"><a href=\"#js实现动画\" class=\"headerlink\" title=\"js实现动画\"></a>js实现动画</h2><ul>\n<li>通过js中的定时器不断的改变元素的位置和高度模拟动画效果</li>\n<li>通过一个定时器管理函数管理定时器的先后调用顺序或者通过<code>dom2</code>级时间<code>removeEventLisenner</code>函数让元素在js调用定时器期间失去时间响应解决定时器无法顺序调用的各种问题</li>\n</ul>\n"},{"title":"strcpy的实现","date":"2016-11-28T22:12:57.000Z","_content":"\n## 不考虑内存重叠\n\n\tchar * strcpy(char *dest,const char *src)\n\t{\n\t\tchar *ret;\n\t\tif(dest==NULL || src==NULL)//检查是否为空指针\n\t\t\treturn NULL;\n\t\twhile((*dest++=*src++)!='\\0');//复制字符串中的内容\n\t\treturn ret;\n\t}\n\n\n## 考虑内存重叠\n\n\tchar *strcpy(char *dest,const char *src)\n\t{\n\t\tchar *ret=dest;\n\t\tif(dest==NULL || src==NULL)//检查是否为空指针\n\t\t\treturn NULL;\n\t\tmemcpy(dest,src,strlen(src)+1);//调用memcpy函数避免内存重复的情况\n\t\treturn ret;\n\t}\n\n\n#### 说明\n\n+ const修饰源字符串避免对源字符串的修改\n+ 检查指针的有效性避免非法操作\n+ 返回目标字符串的首地址确保字符串的线性\n+ 使用`(*dest++=*src++)!='\\0'`确保字符串的末尾有结束符\n\n\n\n\n\n\n","source":"_posts/strcpy的实现.md","raw":"---\ntitle: strcpy的实现\ndate: 2016-11-28 22:12:57\ntags: C/C++语言\n---\n\n## 不考虑内存重叠\n\n\tchar * strcpy(char *dest,const char *src)\n\t{\n\t\tchar *ret;\n\t\tif(dest==NULL || src==NULL)//检查是否为空指针\n\t\t\treturn NULL;\n\t\twhile((*dest++=*src++)!='\\0');//复制字符串中的内容\n\t\treturn ret;\n\t}\n\n\n## 考虑内存重叠\n\n\tchar *strcpy(char *dest,const char *src)\n\t{\n\t\tchar *ret=dest;\n\t\tif(dest==NULL || src==NULL)//检查是否为空指针\n\t\t\treturn NULL;\n\t\tmemcpy(dest,src,strlen(src)+1);//调用memcpy函数避免内存重复的情况\n\t\treturn ret;\n\t}\n\n\n#### 说明\n\n+ const修饰源字符串避免对源字符串的修改\n+ 检查指针的有效性避免非法操作\n+ 返回目标字符串的首地址确保字符串的线性\n+ 使用`(*dest++=*src++)!='\\0'`确保字符串的末尾有结束符\n\n\n\n\n\n\n","slug":"strcpy的实现","published":1,"updated":"2018-03-16T01:14:58.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjet9hysx00081kb1w0ylqpzt","content":"<h2 id=\"不考虑内存重叠\"><a href=\"#不考虑内存重叠\" class=\"headerlink\" title=\"不考虑内存重叠\"></a>不考虑内存重叠</h2><pre><code>char * strcpy(char *dest,const char *src)\n{\n    char *ret;\n    if(dest==NULL || src==NULL)//检查是否为空指针\n        return NULL;\n    while((*dest++=*src++)!=&apos;\\0&apos;);//复制字符串中的内容\n    return ret;\n}\n</code></pre><h2 id=\"考虑内存重叠\"><a href=\"#考虑内存重叠\" class=\"headerlink\" title=\"考虑内存重叠\"></a>考虑内存重叠</h2><pre><code>char *strcpy(char *dest,const char *src)\n{\n    char *ret=dest;\n    if(dest==NULL || src==NULL)//检查是否为空指针\n        return NULL;\n    memcpy(dest,src,strlen(src)+1);//调用memcpy函数避免内存重复的情况\n    return ret;\n}\n</code></pre><h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><ul>\n<li>const修饰源字符串避免对源字符串的修改</li>\n<li>检查指针的有效性避免非法操作</li>\n<li>返回目标字符串的首地址确保字符串的线性</li>\n<li>使用<code>(*dest++=*src++)!=&#39;\\0&#39;</code>确保字符串的末尾有结束符</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"不考虑内存重叠\"><a href=\"#不考虑内存重叠\" class=\"headerlink\" title=\"不考虑内存重叠\"></a>不考虑内存重叠</h2><pre><code>char * strcpy(char *dest,const char *src)\n{\n    char *ret;\n    if(dest==NULL || src==NULL)//检查是否为空指针\n        return NULL;\n    while((*dest++=*src++)!=&apos;\\0&apos;);//复制字符串中的内容\n    return ret;\n}\n</code></pre><h2 id=\"考虑内存重叠\"><a href=\"#考虑内存重叠\" class=\"headerlink\" title=\"考虑内存重叠\"></a>考虑内存重叠</h2><pre><code>char *strcpy(char *dest,const char *src)\n{\n    char *ret=dest;\n    if(dest==NULL || src==NULL)//检查是否为空指针\n        return NULL;\n    memcpy(dest,src,strlen(src)+1);//调用memcpy函数避免内存重复的情况\n    return ret;\n}\n</code></pre><h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><ul>\n<li>const修饰源字符串避免对源字符串的修改</li>\n<li>检查指针的有效性避免非法操作</li>\n<li>返回目标字符串的首地址确保字符串的线性</li>\n<li>使用<code>(*dest++=*src++)!=&#39;\\0&#39;</code>确保字符串的末尾有结束符</li>\n</ul>\n"},{"title":"运算符重载","date":"2017-03-18T16:35:51.000Z","_content":"\nC++中预定义的运算符的操作对象只能是基本数据类型。但实际上，对于许多用户自定义类型（例如类），也需要类似的运算操作。这时就必须在C++中重新定义这些运算符，赋予已有运算符新的功能，使它能够用于特定类型执行特定的操作。运算符重载的实质是函数重载，它提供了C++的可扩展性，也是C++最吸引人的特性之一。\n\n运算符重载是通过创建运算符函数实现的，运算符函数定义了重载的运算符将要进行的操作。运算符函数的定义与其他函数的定义类似，惟一的区别是运算符函数的函数名是由关键字operator和其后要重载的运算符符号构成的。运算符函数定义的一般格式如下：\n\n\t\t<返回类型说明符> operator <运算符符号>(<参数表>)\n\t\t{\n\t\t\t<函数体>\n\t\t}\n\n### 运算符重载规则\n\n+ 除了类属关系运算符\".\"、成员指针运算符\".*\"、作用域运算符\"::\"、sizeof运算符和三目运算符\"?:\"以外，C++中的所有运算符都可以重载。\n\n+ 重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中，不能创建新的运算符。\n\n+ 运算符重载实质上是函数重载，因此编译程序对运算符重载的选择，遵循函数重载的选择原则。\n\n+ 重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。\n\n+ 运算符重载不能改变该运算符用于内部类型对象的含义。它只能和用户自定义类型的对象一起使用，或者用于用户自定义类型的对象和内部类型的对象混合使用时。\n\n+ 运算符重载是针对新类型数据的实际需要对原有运算符进行的适当的改造，重载的功能应当与原有功能相类似，避免没有目的地使用重载运算符。\n\n运算符函数重载一般有两种形式：重载为类的成员函数和重载为类的非成员函数。非成员函数通常是友元。可以把一个运算符作为一个非成员、非友元函数重载。但是，这样的运算符函数访问类的私有和保护成员时，必须使用类的公有接口中提供的设置数据和读取数据的函数，调用这些函数时会降低性能。可以内联这些函数以提高性能。\n\n### 成员函数运算符\n\n运算符重载为类的成员函数的一般格式为：\n\n\t\t<函数类型> operator <运算符>(<参数表>)\n\t\t{\n\t\t\t<函数体>\n\t\t}\n\n\n当运算符重载为类的成员函数时，函数的参数个数比原来的操作数要少一个（后置单目运算符除外），这是因为成员函数用this指针隐式地访问了类的一个对象，它充当了运算符函数最左边的操作数。因此：\n\n+ 双目运算符重载为类的成员函数时，函数只显式说明一个参数，该形参是运算符的右操作数。\n\n+ 前置单目运算符重载为类的成员函数时，不需要显式说明参数，即函数没有形参。\n\n+ 后置单目运算符重载为类的成员函数时，函数要带有一个整型形参。\n\n调用成员函数运算符的格式如下：\n\n\n\t\t<对象名>.operator <运算符>(<参数>)\n\n\n它等价于\n\n\n\t\t<对象名><运算符><参数>\n\n\n例如：a+b等价于a.operator +(b)。一般情况下，我们采用运算符的习惯表达方式。\n\n### 友元函数运算符\n\n运算符重载为类的友元函数的一般格式为：\n\n\n\t\tfriend <函数类型> operator <运算符>(<参数表>)\n\t\t{\n\t\t\t<函数体>\n\t\t}\n\n\n当运算符重载为类的友元函数时，由于没有隐含的this指针，因此操作数的个数没有变化，所有的操作数都必须通过函数的形参进行传递，函数的参数与操作数自左至右一一对应。\n\n调用友元函数运算符的格式如下：\n\n\n\t\toperator <运算符>(<参数1>,<参数2>)\n\n\n它等价于\n\n\n\t\t<参数1><运算符><参数2>\n\n\n例如：a+b等价于operator +(a,b)。\n\n### 两种重载形式的比较\n\n在多数情况下，将运算符重载为类的成员函数和类的友元函数都是可以的。但成员函数运算符与友元函数运算符也具有各自的一些特点：\n\n+ 一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。\n\n+ 以下一些双目运算符不能重载为类的友元函数：=、()、[]、->。\n\n+ 类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。\n\n+ 若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。\n\n+ 若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。\n\n+ 当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一　个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部　类型的对象，该运算符函数必须作为一个友元函数来实现。\n\n+ 当需要重载运算符具有可交换性时，选择重载为友元函数。\n","source":"_posts/运算符重载.md","raw":"---\ntitle: 运算符重载\ndate: 2017-03-18 16:35:51\ntags: C/C++语言\n---\n\nC++中预定义的运算符的操作对象只能是基本数据类型。但实际上，对于许多用户自定义类型（例如类），也需要类似的运算操作。这时就必须在C++中重新定义这些运算符，赋予已有运算符新的功能，使它能够用于特定类型执行特定的操作。运算符重载的实质是函数重载，它提供了C++的可扩展性，也是C++最吸引人的特性之一。\n\n运算符重载是通过创建运算符函数实现的，运算符函数定义了重载的运算符将要进行的操作。运算符函数的定义与其他函数的定义类似，惟一的区别是运算符函数的函数名是由关键字operator和其后要重载的运算符符号构成的。运算符函数定义的一般格式如下：\n\n\t\t<返回类型说明符> operator <运算符符号>(<参数表>)\n\t\t{\n\t\t\t<函数体>\n\t\t}\n\n### 运算符重载规则\n\n+ 除了类属关系运算符\".\"、成员指针运算符\".*\"、作用域运算符\"::\"、sizeof运算符和三目运算符\"?:\"以外，C++中的所有运算符都可以重载。\n\n+ 重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中，不能创建新的运算符。\n\n+ 运算符重载实质上是函数重载，因此编译程序对运算符重载的选择，遵循函数重载的选择原则。\n\n+ 重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。\n\n+ 运算符重载不能改变该运算符用于内部类型对象的含义。它只能和用户自定义类型的对象一起使用，或者用于用户自定义类型的对象和内部类型的对象混合使用时。\n\n+ 运算符重载是针对新类型数据的实际需要对原有运算符进行的适当的改造，重载的功能应当与原有功能相类似，避免没有目的地使用重载运算符。\n\n运算符函数重载一般有两种形式：重载为类的成员函数和重载为类的非成员函数。非成员函数通常是友元。可以把一个运算符作为一个非成员、非友元函数重载。但是，这样的运算符函数访问类的私有和保护成员时，必须使用类的公有接口中提供的设置数据和读取数据的函数，调用这些函数时会降低性能。可以内联这些函数以提高性能。\n\n### 成员函数运算符\n\n运算符重载为类的成员函数的一般格式为：\n\n\t\t<函数类型> operator <运算符>(<参数表>)\n\t\t{\n\t\t\t<函数体>\n\t\t}\n\n\n当运算符重载为类的成员函数时，函数的参数个数比原来的操作数要少一个（后置单目运算符除外），这是因为成员函数用this指针隐式地访问了类的一个对象，它充当了运算符函数最左边的操作数。因此：\n\n+ 双目运算符重载为类的成员函数时，函数只显式说明一个参数，该形参是运算符的右操作数。\n\n+ 前置单目运算符重载为类的成员函数时，不需要显式说明参数，即函数没有形参。\n\n+ 后置单目运算符重载为类的成员函数时，函数要带有一个整型形参。\n\n调用成员函数运算符的格式如下：\n\n\n\t\t<对象名>.operator <运算符>(<参数>)\n\n\n它等价于\n\n\n\t\t<对象名><运算符><参数>\n\n\n例如：a+b等价于a.operator +(b)。一般情况下，我们采用运算符的习惯表达方式。\n\n### 友元函数运算符\n\n运算符重载为类的友元函数的一般格式为：\n\n\n\t\tfriend <函数类型> operator <运算符>(<参数表>)\n\t\t{\n\t\t\t<函数体>\n\t\t}\n\n\n当运算符重载为类的友元函数时，由于没有隐含的this指针，因此操作数的个数没有变化，所有的操作数都必须通过函数的形参进行传递，函数的参数与操作数自左至右一一对应。\n\n调用友元函数运算符的格式如下：\n\n\n\t\toperator <运算符>(<参数1>,<参数2>)\n\n\n它等价于\n\n\n\t\t<参数1><运算符><参数2>\n\n\n例如：a+b等价于operator +(a,b)。\n\n### 两种重载形式的比较\n\n在多数情况下，将运算符重载为类的成员函数和类的友元函数都是可以的。但成员函数运算符与友元函数运算符也具有各自的一些特点：\n\n+ 一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。\n\n+ 以下一些双目运算符不能重载为类的友元函数：=、()、[]、->。\n\n+ 类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。\n\n+ 若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。\n\n+ 若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。\n\n+ 当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一　个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部　类型的对象，该运算符函数必须作为一个友元函数来实现。\n\n+ 当需要重载运算符具有可交换性时，选择重载为友元函数。\n","slug":"运算符重载","published":1,"updated":"2018-03-16T01:14:58.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjet9hysy00091kb12h4nulev","content":"<p>C++中预定义的运算符的操作对象只能是基本数据类型。但实际上，对于许多用户自定义类型（例如类），也需要类似的运算操作。这时就必须在C++中重新定义这些运算符，赋予已有运算符新的功能，使它能够用于特定类型执行特定的操作。运算符重载的实质是函数重载，它提供了C++的可扩展性，也是C++最吸引人的特性之一。</p>\n<p>运算符重载是通过创建运算符函数实现的，运算符函数定义了重载的运算符将要进行的操作。运算符函数的定义与其他函数的定义类似，惟一的区别是运算符函数的函数名是由关键字operator和其后要重载的运算符符号构成的。运算符函数定义的一般格式如下：</p>\n<pre><code>&lt;返回类型说明符&gt; operator &lt;运算符符号&gt;(&lt;参数表&gt;)\n{\n    &lt;函数体&gt;\n}\n</code></pre><h3 id=\"运算符重载规则\"><a href=\"#运算符重载规则\" class=\"headerlink\" title=\"运算符重载规则\"></a>运算符重载规则</h3><ul>\n<li><p>除了类属关系运算符”.”、成员指针运算符”.*”、作用域运算符”::”、sizeof运算符和三目运算符”?:”以外，C++中的所有运算符都可以重载。</p>\n</li>\n<li><p>重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中，不能创建新的运算符。</p>\n</li>\n<li><p>运算符重载实质上是函数重载，因此编译程序对运算符重载的选择，遵循函数重载的选择原则。</p>\n</li>\n<li><p>重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。</p>\n</li>\n<li><p>运算符重载不能改变该运算符用于内部类型对象的含义。它只能和用户自定义类型的对象一起使用，或者用于用户自定义类型的对象和内部类型的对象混合使用时。</p>\n</li>\n<li><p>运算符重载是针对新类型数据的实际需要对原有运算符进行的适当的改造，重载的功能应当与原有功能相类似，避免没有目的地使用重载运算符。</p>\n</li>\n</ul>\n<p>运算符函数重载一般有两种形式：重载为类的成员函数和重载为类的非成员函数。非成员函数通常是友元。可以把一个运算符作为一个非成员、非友元函数重载。但是，这样的运算符函数访问类的私有和保护成员时，必须使用类的公有接口中提供的设置数据和读取数据的函数，调用这些函数时会降低性能。可以内联这些函数以提高性能。</p>\n<h3 id=\"成员函数运算符\"><a href=\"#成员函数运算符\" class=\"headerlink\" title=\"成员函数运算符\"></a>成员函数运算符</h3><p>运算符重载为类的成员函数的一般格式为：</p>\n<pre><code>&lt;函数类型&gt; operator &lt;运算符&gt;(&lt;参数表&gt;)\n{\n    &lt;函数体&gt;\n}\n</code></pre><p>当运算符重载为类的成员函数时，函数的参数个数比原来的操作数要少一个（后置单目运算符除外），这是因为成员函数用this指针隐式地访问了类的一个对象，它充当了运算符函数最左边的操作数。因此：</p>\n<ul>\n<li><p>双目运算符重载为类的成员函数时，函数只显式说明一个参数，该形参是运算符的右操作数。</p>\n</li>\n<li><p>前置单目运算符重载为类的成员函数时，不需要显式说明参数，即函数没有形参。</p>\n</li>\n<li><p>后置单目运算符重载为类的成员函数时，函数要带有一个整型形参。</p>\n</li>\n</ul>\n<p>调用成员函数运算符的格式如下：</p>\n<pre><code>&lt;对象名&gt;.operator &lt;运算符&gt;(&lt;参数&gt;)\n</code></pre><p>它等价于</p>\n<pre><code>&lt;对象名&gt;&lt;运算符&gt;&lt;参数&gt;\n</code></pre><p>例如：a+b等价于a.operator +(b)。一般情况下，我们采用运算符的习惯表达方式。</p>\n<h3 id=\"友元函数运算符\"><a href=\"#友元函数运算符\" class=\"headerlink\" title=\"友元函数运算符\"></a>友元函数运算符</h3><p>运算符重载为类的友元函数的一般格式为：</p>\n<pre><code>friend &lt;函数类型&gt; operator &lt;运算符&gt;(&lt;参数表&gt;)\n{\n    &lt;函数体&gt;\n}\n</code></pre><p>当运算符重载为类的友元函数时，由于没有隐含的this指针，因此操作数的个数没有变化，所有的操作数都必须通过函数的形参进行传递，函数的参数与操作数自左至右一一对应。</p>\n<p>调用友元函数运算符的格式如下：</p>\n<pre><code>operator &lt;运算符&gt;(&lt;参数1&gt;,&lt;参数2&gt;)\n</code></pre><p>它等价于</p>\n<pre><code>&lt;参数1&gt;&lt;运算符&gt;&lt;参数2&gt;\n</code></pre><p>例如：a+b等价于operator +(a,b)。</p>\n<h3 id=\"两种重载形式的比较\"><a href=\"#两种重载形式的比较\" class=\"headerlink\" title=\"两种重载形式的比较\"></a>两种重载形式的比较</h3><p>在多数情况下，将运算符重载为类的成员函数和类的友元函数都是可以的。但成员函数运算符与友元函数运算符也具有各自的一些特点：</p>\n<ul>\n<li><p>一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。</p>\n</li>\n<li><p>以下一些双目运算符不能重载为类的友元函数：=、()、[]、-&gt;。</p>\n</li>\n<li><p>类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。</p>\n</li>\n<li><p>若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。</p>\n</li>\n<li><p>若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。</p>\n</li>\n<li><p>当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一　个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部　类型的对象，该运算符函数必须作为一个友元函数来实现。</p>\n</li>\n<li><p>当需要重载运算符具有可交换性时，选择重载为友元函数。</p>\n</li>\n</ul>\n","excerpt":"","more":"<p>C++中预定义的运算符的操作对象只能是基本数据类型。但实际上，对于许多用户自定义类型（例如类），也需要类似的运算操作。这时就必须在C++中重新定义这些运算符，赋予已有运算符新的功能，使它能够用于特定类型执行特定的操作。运算符重载的实质是函数重载，它提供了C++的可扩展性，也是C++最吸引人的特性之一。</p>\n<p>运算符重载是通过创建运算符函数实现的，运算符函数定义了重载的运算符将要进行的操作。运算符函数的定义与其他函数的定义类似，惟一的区别是运算符函数的函数名是由关键字operator和其后要重载的运算符符号构成的。运算符函数定义的一般格式如下：</p>\n<pre><code>&lt;返回类型说明符&gt; operator &lt;运算符符号&gt;(&lt;参数表&gt;)\n{\n    &lt;函数体&gt;\n}\n</code></pre><h3 id=\"运算符重载规则\"><a href=\"#运算符重载规则\" class=\"headerlink\" title=\"运算符重载规则\"></a>运算符重载规则</h3><ul>\n<li><p>除了类属关系运算符”.”、成员指针运算符”.*”、作用域运算符”::”、sizeof运算符和三目运算符”?:”以外，C++中的所有运算符都可以重载。</p>\n</li>\n<li><p>重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中，不能创建新的运算符。</p>\n</li>\n<li><p>运算符重载实质上是函数重载，因此编译程序对运算符重载的选择，遵循函数重载的选择原则。</p>\n</li>\n<li><p>重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。</p>\n</li>\n<li><p>运算符重载不能改变该运算符用于内部类型对象的含义。它只能和用户自定义类型的对象一起使用，或者用于用户自定义类型的对象和内部类型的对象混合使用时。</p>\n</li>\n<li><p>运算符重载是针对新类型数据的实际需要对原有运算符进行的适当的改造，重载的功能应当与原有功能相类似，避免没有目的地使用重载运算符。</p>\n</li>\n</ul>\n<p>运算符函数重载一般有两种形式：重载为类的成员函数和重载为类的非成员函数。非成员函数通常是友元。可以把一个运算符作为一个非成员、非友元函数重载。但是，这样的运算符函数访问类的私有和保护成员时，必须使用类的公有接口中提供的设置数据和读取数据的函数，调用这些函数时会降低性能。可以内联这些函数以提高性能。</p>\n<h3 id=\"成员函数运算符\"><a href=\"#成员函数运算符\" class=\"headerlink\" title=\"成员函数运算符\"></a>成员函数运算符</h3><p>运算符重载为类的成员函数的一般格式为：</p>\n<pre><code>&lt;函数类型&gt; operator &lt;运算符&gt;(&lt;参数表&gt;)\n{\n    &lt;函数体&gt;\n}\n</code></pre><p>当运算符重载为类的成员函数时，函数的参数个数比原来的操作数要少一个（后置单目运算符除外），这是因为成员函数用this指针隐式地访问了类的一个对象，它充当了运算符函数最左边的操作数。因此：</p>\n<ul>\n<li><p>双目运算符重载为类的成员函数时，函数只显式说明一个参数，该形参是运算符的右操作数。</p>\n</li>\n<li><p>前置单目运算符重载为类的成员函数时，不需要显式说明参数，即函数没有形参。</p>\n</li>\n<li><p>后置单目运算符重载为类的成员函数时，函数要带有一个整型形参。</p>\n</li>\n</ul>\n<p>调用成员函数运算符的格式如下：</p>\n<pre><code>&lt;对象名&gt;.operator &lt;运算符&gt;(&lt;参数&gt;)\n</code></pre><p>它等价于</p>\n<pre><code>&lt;对象名&gt;&lt;运算符&gt;&lt;参数&gt;\n</code></pre><p>例如：a+b等价于a.operator +(b)。一般情况下，我们采用运算符的习惯表达方式。</p>\n<h3 id=\"友元函数运算符\"><a href=\"#友元函数运算符\" class=\"headerlink\" title=\"友元函数运算符\"></a>友元函数运算符</h3><p>运算符重载为类的友元函数的一般格式为：</p>\n<pre><code>friend &lt;函数类型&gt; operator &lt;运算符&gt;(&lt;参数表&gt;)\n{\n    &lt;函数体&gt;\n}\n</code></pre><p>当运算符重载为类的友元函数时，由于没有隐含的this指针，因此操作数的个数没有变化，所有的操作数都必须通过函数的形参进行传递，函数的参数与操作数自左至右一一对应。</p>\n<p>调用友元函数运算符的格式如下：</p>\n<pre><code>operator &lt;运算符&gt;(&lt;参数1&gt;,&lt;参数2&gt;)\n</code></pre><p>它等价于</p>\n<pre><code>&lt;参数1&gt;&lt;运算符&gt;&lt;参数2&gt;\n</code></pre><p>例如：a+b等价于operator +(a,b)。</p>\n<h3 id=\"两种重载形式的比较\"><a href=\"#两种重载形式的比较\" class=\"headerlink\" title=\"两种重载形式的比较\"></a>两种重载形式的比较</h3><p>在多数情况下，将运算符重载为类的成员函数和类的友元函数都是可以的。但成员函数运算符与友元函数运算符也具有各自的一些特点：</p>\n<ul>\n<li><p>一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数。</p>\n</li>\n<li><p>以下一些双目运算符不能重载为类的友元函数：=、()、[]、-&gt;。</p>\n</li>\n<li><p>类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。</p>\n</li>\n<li><p>若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好。</p>\n</li>\n<li><p>若运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则只能选用友元函数。</p>\n</li>\n<li><p>当运算符函数是一个成员函数时，最左边的操作数（或者只有最左边的操作数）必须是运算符类的一　个类对象（或者是对该类对象的引用）。如果左边的操作数必须是一个不同类的对象，或者是一个内部　类型的对象，该运算符函数必须作为一个友元函数来实现。</p>\n</li>\n<li><p>当需要重载运算符具有可交换性时，选择重载为友元函数。</p>\n</li>\n</ul>\n"},{"title":"各种资源","date":"2016-11-05T00:20:31.000Z","_content":"\n## 文档\n\n+ [hexo文档](https://hexo.io/zh-cn/docs/index.html)\n","source":"_posts/source01.md","raw":"---\ntitle: 各种资源\ndate: 2016-11-05 00:20:31\ntags: 资源\n---\n\n## 文档\n\n+ [hexo文档](https://hexo.io/zh-cn/docs/index.html)\n","slug":"source01","published":1,"updated":"2018-03-16T01:14:58.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjet9hyt0000b1kb11ln41fau","content":"<h2 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h2><ul>\n<li><a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"external\">hexo文档</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h2><ul>\n<li><a href=\"https://hexo.io/zh-cn/docs/index.html\">hexo文档</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjet9hysm00001kb1f17r77nb","tag_id":"cjet9hysr00021kb1kwha10mk","_id":"cjet9hysw00071kb1hvwyj5ab"},{"post_id":"cjet9hysp00011kb1rj6j23xd","tag_id":"cjet9hysw00061kb1wwdo0reh","_id":"cjet9hyt0000c1kb1jvweld4t"},{"post_id":"cjet9hyst00031kb1uec1pnuv","tag_id":"cjet9hysz000a1kb1wmt1em0y","_id":"cjet9hyt2000e1kb1zlifpl3p"},{"post_id":"cjet9hysu00041kb11ulf4spy","tag_id":"cjet9hyt1000d1kb1o7uwxlnq","_id":"cjet9hyt3000g1kb131qxrmaf"},{"post_id":"cjet9hysv00051kb1lwtktl1x","tag_id":"cjet9hysw00061kb1wwdo0reh","_id":"cjet9hyt5000i1kb1py3xnp7n"},{"post_id":"cjet9hysx00081kb1w0ylqpzt","tag_id":"cjet9hyt1000d1kb1o7uwxlnq","_id":"cjet9hyt6000k1kb1g94ibu9j"},{"post_id":"cjet9hysy00091kb12h4nulev","tag_id":"cjet9hyt1000d1kb1o7uwxlnq","_id":"cjet9hyt7000m1kb17dspqn1b"},{"post_id":"cjet9hyt0000b1kb11ln41fau","tag_id":"cjet9hyt6000l1kb18yinx7ul","_id":"cjet9hyt8000n1kb1bdizf47q"}],"Tag":[{"name":"计算机网络","_id":"cjet9hysr00021kb1kwha10mk"},{"name":"JavaScript","_id":"cjet9hysw00061kb1wwdo0reh"},{"name":"其它","_id":"cjet9hysz000a1kb1wmt1em0y"},{"name":"C/C++语言","_id":"cjet9hyt1000d1kb1o7uwxlnq"},{"name":"资源","_id":"cjet9hyt6000l1kb18yinx7ul"}]}}