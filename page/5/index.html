<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>奔跑的蜗牛</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前端开发工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="奔跑的蜗牛">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="奔跑的蜗牛">
<meta property="og:description" content="前端开发工程师">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="奔跑的蜗牛">
<meta property="article:tag" content="React、node、webpack">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="0001.jpg#/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="奔跑的蜗牛" type="application/atom+xml">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">奔跑的蜗牛</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">分类</a>
        
      </nav>
      <nav id="sub-nav">
        
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-react中的异步实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/30/react%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2021-05-30T13:37:54.000Z" itemprop="datePublished">2021-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/30/react%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0/">react中的异步实现</a>
    </h1>
  


        <div style="color: #999; margin-top: 0.3rem" class="post-meta-item"> 共计
    1.4k 字，约需阅读
    5.09
    分钟
</div>
      </header>
    
    
   

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>由于 <code>JS</code> 是单线程非阻塞的，所有的任务都需要在这个线程中来处理。当需要执行异步任务时主线程会先挂起这个任务，当异步任务执行完毕之后主线程会根据规则执行回调。当任务处理完毕之后， <code>JS</code> 会将这个事件加入队列中，这个队列即被称为事件队列。</p>
<h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><ul>
<li>进程： <code>CPU</code> 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li>
<li>线程： 进程中的更小单位，描述了执行一段指令所需的时间。</li>
</ul>
<p>在浏览器中，当你打开一个 <code>Tab</code> 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、<code>JS</code> 引擎线程、<code>HTTP</code> 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p>
<p>在 <code>JS</code> 运行的时候会阻止 <code>UI</code> 渲染，这是因为 <code>JS</code> 可以修改 <code>DOM</code>，如果在 <code>JS</code> 执行的时候 <code>UI</code> 线程还在工作，就可能导致不能安全的渲染 <code>UI</code>。这其实也是一个单线程的好处，得益于 <code>JS</code> 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处。</p>
<p>对于锁的问题，形象的来说就是当我读取一个数字 <code>15</code> 的时候，同时有两个操作对数字进行了加减，这时候结果就出现了错误。解决这个问题也不难，只需要在读取的时候加锁，直到读取完毕之前都不能进行写入操作。</p>
<h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>所有的 <code>JS</code> 代码在运行时都是在执行上下文中进行的。<code>JS</code> 中有三种执行上下文：</p>
<ul>
<li>全局执行上下文，默认的，浏览器中是 <code>window</code> 对象，<code>nodejs</code> 中是 <code>global</code>，并且 <code>this</code> 在非严格模式下指向它们。</li>
<li>函数执行上下文，<code>JS</code> 的函数每当被调用时会创建一个上下文。</li>
<li><code>Eval</code> 执行上下文，<code>eval</code> 函数会产生自己的上下文。</li>
</ul>
<p>栈是一种数据结构，具有先进后出的原则。<code>JS</code> 中的执行栈就具有这样的结构，当引擎第一次遇到 <code>JS</code> 代码时，会产生一个全局执行上下文并压入执行栈，每遇到一个函数调用，就会往栈中压入一个新的上下文。引擎执行栈顶的函数，执行完毕，弹出当前执行上下文。</p>
<h4 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h4><p>异步任务被分为两种类型，微任务和宏任务</p>
<h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5><ul>
<li><code>Promise.then</code></li>
<li><code>MutationObserver</code></li>
<li><code>process.nextTick</code></li>
</ul>
<h5 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h5><ul>
<li><code>script</code>(整体代码)</li>
<li><code>setTimout</code></li>
<li><code>setInterval</code></li>
<li><code>setImmediate</code></li>
<li><code>MessageChannel</code></li>
<li><code>requestAnimationFrame</code></li>
<li><code>postMessage</code></li>
<li><code>I/O</code></li>
<li><code>UI</code> 交互事件</li>
</ul>
<h4 id="事件循环-1"><a href="#事件循环-1" class="headerlink" title="事件循环"></a>事件循环</h4><p><code>Event Loop</code>(事件循环)中，每一次循环称为 <code>tick</code>, 每一次 <code>tick</code> 的任务如下：</p>
<ol>
<li>执行栈选择最先进入队列的宏任务(通常是 <code>script</code> 整体代码)，如果有则执行</li>
<li>检查是否存在 <code>Microtask</code>，如果存在则不停的执行，直至清空 <code>microtask</code> 队列</li>
<li>更新 <code>render</code>(每一次事件循环，浏览器都可能会去更新渲染)</li>
<li>重复以上步骤</li>
</ol>
<p>宏任务 &gt; 所有微任务 &gt; 宏任务，如下图所示：</p>
<p><img src="/images/js/eventLoop.jpg" alt="事件循环"></p>
<ol>
<li>将所有任务看成两个队列：执行队列与事件队列。</li>
<li>执行队列是同步的，事件队列是异步的，宏任务放入事件列表，微任务放入执行队列之后，事件队列之前。</li>
<li>当执行完同步代码之后，就会执行位于执行列表之后的微任务，然后再执行事件列表中的宏任务</li>
</ol>
<h3 id="react-中的异步实现"><a href="#react-中的异步实现" class="headerlink" title="react 中的异步实现"></a>react 中的异步实现</h3><p><code>react</code> 中的异步是通过宏任务来实现的，优先使用 <code>setImmediate</code> ，然后使用 <code>MessageChannel</code>，若都不支持则使用 <code>setTimeout</code> 实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schedulePerformWorkUntilDeadline</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> localSetImmediate === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// Node.js and old IE.</span></span><br><span class="line">  <span class="comment">// There&#x27;s a few reasons for why we prefer setImmediate.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Unlike MessageChannel, it doesn&#x27;t prevent a Node.js process from exiting.</span></span><br><span class="line">  <span class="comment">// (Even though this is a DOM fork of the Scheduler, you could get here</span></span><br><span class="line">  <span class="comment">// with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)</span></span><br><span class="line">  <span class="comment">// https://github.com/facebook/react/issues/20756</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// But also, it runs earlier which is the semantic we want.</span></span><br><span class="line">  <span class="comment">// If other browsers ever implement it, it&#x27;s better to use it.</span></span><br><span class="line">  <span class="comment">// Although both of these would be inferior to native scheduling.</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">localSetImmediate</span>(performWorkUntilDeadline)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">MessageChannel</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// DOM and Worker environments.</span></span><br><span class="line">  <span class="comment">// We prefer MessageChannel because of the 4ms setTimeout clamping.</span></span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>()</span><br><span class="line">  <span class="keyword">const</span> port = channel.<span class="property">port2</span></span><br><span class="line">  channel.<span class="property">port1</span>.<span class="property">onmessage</span> = performWorkUntilDeadline</span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    port.<span class="title function_">postMessage</span>(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// We should only fallback here in non-browser environments.</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">localSetTimeout</span>(performWorkUntilDeadline, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>判断是否存在 <code>setImmediate</code>，如果存在则使用 <code>setImmediate</code>，不存在下一步</li>
<li>判断是否支持 <code>MessageChannel</code>，如果支持则创建一个消息通道，通过消息通道实现宏任务，否则进行下一步</li>
<li>回落到 <code>setTimeout</code> 实现异步</li>
</ol>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li>优先选择 <code>MessageChannel</code> 而不是 <code>setTimeout</code> 的原因是由于 <code>setTimeout</code> 有一个最小 <code>4ms</code> 的等待时间，在无宏任务执行时，这个时间会浪费掉</li>
<li>不选择微任务的原因是，使用微任务的方式时，当前任务任然占据了主线程而没有释放出来，达不到把主线程还给渲染线程的目的</li>
</ol>
<h5 id="edge-浏览器测试参考"><a href="#edge-浏览器测试参考" class="headerlink" title="edge 浏览器测试参考"></a><code>edge</code> 浏览器测试参考</h5><p><img src="/images/js/macroTask.png" alt="事件循环"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/59784952">深入理解 JavaScript 执行上下文和执行栈</a></li>
<li><a href="https://segmentfault.com/a/1190000015317434">Js 的事件循环(Event Loop)机制以及实例讲解</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel">MessageChannel</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/30/react%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0/" data-id="cm1ghkbn7003hzodze92g95o2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/" rel="tag">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-前端框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/18/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" class="article-date">
  <time datetime="2021-04-17T22:48:43.000Z" itemprop="datePublished">2021-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/18/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/">前端框架</a>
    </h1>
  


        <div style="color: #999; margin-top: 0.3rem" class="post-meta-item"> 共计
    796 字，约需阅读
    2.89
    分钟
</div>
      </header>
    
    
   

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="DOM-操作时代"><a href="#DOM-操作时代" class="headerlink" title="DOM 操作时代"></a>DOM 操作时代</h3><p>代表库 <a href="https://jquery.com/"><code>jQuery</code></a> 和 <a href="https://zeptojs.com/"><code>zepto</code></a></p>
<ul>
<li>简化选择器</li>
<li>简化 <code>DOM</code> 操作</li>
<li>简化 <code>AJAX</code> 操作</li>
<li>统一事件绑定</li>
<li>兼容性实现</li>
<li>延时对象（<code>$.Deferred</code>）</li>
</ul>
<h4 id="DOM-操作的一般流程"><a href="#DOM-操作的一般流程" class="headerlink" title="DOM 操作的一般流程"></a>DOM 操作的一般流程</h4><ol>
<li><code>DOM</code> 加载</li>
<li><code>js</code> 脚本加载</li>
<li><code>js</code>脚本执行，发送异步请求获取数据</li>
<li>操作 <code>DOM</code> 进行数据渲染</li>
<li>对 <code>DOM</code> 节点进行事件绑定</li>
</ol>
<p><img src="/images/domprocess.png" alt="DOM 操作流程"></p>
<h3 id="MV-交互模式"><a href="#MV-交互模式" class="headerlink" title="MV* 交互模式"></a>MV* 交互模式</h3><h4 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h4><p>将 <code>DOM</code> 交互部分的内容分为数据模型、视图和事件控制三部分</p>
<ul>
<li><code>Model</code>：存放请求的数据结果和数据对象</li>
<li><code>View</code>: 页面 <code>DOM</code> 的更新与修改</li>
<li><code>Controller</code>: 根据前端路由条件调用不同的 <code>Model</code> 和 <code>View</code>渲染不同的数据内容</li>
</ul>
<p>用户的操作直接通过 <code>Controller</code> 控制</p>
<h4 id="MVP-模式"><a href="#MVP-模式" class="headerlink" title="MVP 模式"></a>MVP 模式</h4><p><code>Model-View-Presenter</code>，将 <code>DOM</code> 交互部分的内容分为数据模型、视图和 <code>Presenter</code> 三部分</p>
<ul>
<li><code>Model</code>：存放请求的数据结果和数据对象（仅提供数据）</li>
<li><code>View</code>: 页面 <code>DOM</code> 的更新与修改（仅提供视图模板）</li>
<li><code>Presenter</code>: 根据前端路由条件调用不同的 <code>Model</code> 和 <code>View</code>渲染不同的数据内容（主要的逻辑处理）</li>
</ul>
<p><code>Presenter</code> 与 <code>View</code> 的绑定是双向的，<code>Presenter</code> 的改变会改变 <code>View</code>，<code>View</code> 的改变也会触发 <code>Presenter</code>，所有的逻辑调用数据和渲染视图 <code>View</code> 模板都在 <code>Presenter</code> 中完成，同时用户在 <code>View</code> 层操作的改变反馈到 <code>Presenter</code> 改变 <code>Model</code>并渲染新的 <code>View</code> 视图。</p>
<ul>
<li>优点：只需关注 <code>Presenter</code> 的逻辑</li>
<li>缺点：内容较重</li>
</ul>
<h4 id="MVVM-模式"><a href="#MVVM-模式" class="headerlink" title="MVVM 模式"></a>MVVM 模式</h4><p>自动化的 <code>MVP</code> 框架，用 <code>ViewModel</code> 代替 <code>Presenter</code>，<code>Model</code> 的调用和 <code>View</code> 由 <code>ViewModel</code> 自动触发完成<br>用户操作时， <code>ViewModel</code> 捕获数据变化，将变化反应到 <code>View</code> 上。 <code>ViewModel</code> 的数据操作最终在页面上以 <code>Directive</code> 的形式体现，通过对 <code>Directive</code> 的识别来渲染数据或绑定事件。</p>
<h5 id="通用基本设计"><a href="#通用基本设计" class="headerlink" title="通用基本设计"></a>通用基本设计</h5><ul>
<li><code>Directive</code>: 指令，即自定义执行函数</li>
<li><code>Filter</code>: 过滤器，对传入的初始数据信进行处理，然后把处理结果交给下一步（<code>Directive</code> 或 <code>Filter</code>）。</li>
<li>表达式：控制页面内容按照具体条件展示</li>
<li><code>ViewModel</code>: 实现传入的 <code>Model</code> 数据在内存中存放，也提供一些基本的读取或修改数据的 <code>API</code></li>
<li>数据变更检查： 即数据变化自动触发其它操作，通过手动触发、脏检测、对象劫持、<code>Proxy</code> 等</li>
</ul>
<h6 id="数据变更检查"><a href="#数据变更检查" class="headerlink" title="数据变更检查"></a>数据变更检查</h6><ul>
<li>手动触发: 通过在数据对象上定义 <code>get</code> 和 <code>set</code> 方法，调用时手动触发 <code>get</code> 和 <code>set</code> 来获取和修改数据，改变后主动触发 <code>get</code> 和 <code>set</code> 中 <code>View</code> 层的重新渲染功能</li>
<li>脏检测: 在 <code>ViewModel</code> 对象的某个属性值发生变化时找到与这个属性值相关的所有元素，然后比较数据变化，如果有变化则进行 <code>Directive</code> 指令调用，对这个元素进行重新扫描渲染</li>
<li>前端数据对象劫持： 使用 <code>Object.defineProperty</code> 和 <code>Object.defineProperties</code> 对 <code>ViewModel</code> 数据对象进行属性 <code>get</code> 和 <code>set</code> 的监听，当有数据读取和赋值时则扫描节点元素，运行指定对应节点的 <code>Directive</code> 指令。</li>
<li><code>ES6 Proxy</code>:类似与 <code>Object.defineProperty</code> 和 <code>Object.defineProperties</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/18/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" data-id="cm1ghkbnf004gzodzhiodh7p4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/other/" rel="tag">other</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-与native交互" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/04/%E4%B8%8Enative%E4%BA%A4%E4%BA%92/" class="article-date">
  <time datetime="2021-04-03T20:06:35.000Z" itemprop="datePublished">2021-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/04/%E4%B8%8Enative%E4%BA%A4%E4%BA%92/">与native交互</a>
    </h1>
  


        <div style="color: #999; margin-top: 0.3rem" class="post-meta-item"> 共计
    647 字，约需阅读
    2.35
    分钟
</div>
      </header>
    
    
   

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Hybird-App"><a href="#Hybird-App" class="headerlink" title="Hybird App"></a><code>Hybird App</code></h3><p>在 <code>Native App</code> 引用基础上结合了 <code>Web App</code> 应用所形成的模式，一般通过 <code>webview</code> 的模式引入</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>系统资源较少，包括 <code>CPU</code> 、内存、网卡、网络链接等。</li>
<li>支持更新的浏览器特性，不用考虑 <code>IE</code> 的兼容性问题</li>
<li>可以实现离线应用，通过新的浏览器特性或 <code>Native</code> 的文件读取机制进行文件级的文件缓存和离线更新</li>
<li>不同机型设备的兼容问题</li>
<li>可以调用客户端 <code>Native</code> 的能力，例如摄像头、定位、传感器、本地文件访问等。</li>
</ul>
<h3 id="Web-到-Native-的协议调用"><a href="#Web-到-Native-的协议调用" class="headerlink" title="Web 到 Native 的协议调用"></a><code>Web</code> 到 <code>Native</code> 的协议调用</h3><h4 id="通过-URI-请求"><a href="#通过-URI-请求" class="headerlink" title="通过 URI 请求"></a>通过 <code>URI</code> 请求</h4><p>在系统中注册一个 <code>Schema</code> 协议的 <code>URI</code> ，这个 <code>URI</code> 可以在系统的任意地方调起一段原生方法或一个原生的界面</p>
<p><img src="/images/webtonative.svg" alt="`web` 通过 `URI` 请求 `Native` 流程"></p>
<h4 id="通过-addJavascriptInterface-注入方法到页面中调用"><a href="#通过-addJavascriptInterface-注入方法到页面中调用" class="headerlink" title="通过 addJavascriptInterface 注入方法到页面中调用"></a>通过 <code>addJavascriptInterface</code> 注入方法到页面中调用</h4><p>通过 <code>addJavascriptInterface</code> 方法向页面中注入一个全局对象以供调用</p>
<h4 id="注入对象"><a href="#注入对象" class="headerlink" title="注入对象"></a>注入对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 ws 实例</span></span><br><span class="line"><span class="type">WebSettings</span> <span class="variable">ws</span> <span class="operator">=</span> webView.getSetting();</span><br><span class="line"><span class="comment">// 开启执行 JavaScript 脚本</span></span><br><span class="line">ws.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 加载页面</span></span><br><span class="line">ws.loadUrl(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">// 注入全局对象</span></span><br><span class="line">ws.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="string">&quot;native&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 调用注入的 native 方法</span></span></span><br><span class="line"><span class="language-javascript">    native.<span class="title function_">method</span>()</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Native-到-Web-的调用"><a href="#Native-到-Web-的调用" class="headerlink" title="Native 到 Web 的调用"></a><code>Native</code> 到 <code>Web</code> 的调用</h3><ul>
<li>安卓：通过 <code>webView.loadUrl</code> 方法实现</li>
<li>iOS ：通过 <code>stringByEvaluatingJavaScriptFromString</code> 方法实现</li>
</ul>
<h4 id="html-定义方法"><a href="#html-定义方法" class="headerlink" title="html 定义方法"></a>html 定义方法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">msg</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="原生调用"><a href="#原生调用" class="headerlink" title="原生调用"></a>原生调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 ws 实例</span></span><br><span class="line"><span class="type">WebSettings</span> <span class="variable">ws</span> <span class="operator">=</span> webView.getSetting();</span><br><span class="line"><span class="comment">// 开启执行 JavaScript 脚本</span></span><br><span class="line">ws.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 加载页面</span></span><br><span class="line">ws.loadUrl(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">// 调用 js 方法</span></span><br><span class="line">webView.loadUr(<span class="string">&quot;javascript: log(&#x27;hello world&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="JSBridge"><a href="#JSBridge" class="headerlink" title="JSBridge"></a><code>JSBridge</code></h3><p>通信规则： <code>jsBridge://className:callbackMethod/methodName?jsonObj</code></p>
<h4 id="安卓实现"><a href="#安卓实现" class="headerlink" title="安卓实现"></a>安卓实现</h4><p>通过 <code>prompt</code> 方式调用。 <code>addJavascriptInterface</code> 存在安全漏洞，可以通过 <code>JavascriptInterface</code> 来解决，但是其存在兼容性问题。所以通过 <code>webView.setWebChromeClient</code> 来实现： <code>JavaScript</code> 在执行 <code>alert</code> 和 <code>prompt</code> 时， <code>Native</code> 端会自动触发 <code>onJsAlert</code> 和 <code>onJsPrompt</code> 的方法回调函数，由于 <code>alert</code> 比较常用，所以可以通过重写 <code>onJsPrompt</code> 的方法实现对 <code>Native</code> 端方法的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 prompt 监听</span></span><br><span class="line">webView.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsPrompt</span><span class="params">(WebView wv, String url, String msg, String defaultValue, JsPromptResult res)</span> &#123;</span><br><span class="line">        res.confirm(JSBridge.callJsPrompt(MainActivity.<span class="built_in">this</span>, wv, msg));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="iOS-实现"><a href="#iOS-实现" class="headerlink" title="iOS 实现"></a><code>iOS</code> 实现</h4><p>通过 <code>iframe</code> 的方式调用</p>
<h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><ol>
<li>安卓通过 <code>prompt(jsBridge://className:callbackMethod/methodName?jsonObj)</code> 调用，<code>iOS</code> 通过 <code>iframe</code> 方式调用</li>
<li><code>Native</code> 解析协议，调用对应的 <code>className</code> 对象中的 <code>methodName</code> 方法，并把对应的参数 <code>jsonObj</code> 序列化后作为方法的参数</li>
<li>执行完成后调用 <code>JavaScript</code> 回调函数返回结果</li>
</ol>
<p><img src="/images/jsbridge.svg" alt="调用流程"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/04/%E4%B8%8Enative%E4%BA%A4%E4%BA%92/" data-id="cm1ghkbne004bzodzghg53ql3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/other/" rel="tag">other</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-实时协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/02/%E5%AE%9E%E6%97%B6%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2021-04-01T23:38:14.000Z" itemprop="datePublished">2021-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/02/%E5%AE%9E%E6%97%B6%E5%8D%8F%E8%AE%AE/">实时协议</a>
    </h1>
  


        <div style="color: #999; margin-top: 0.3rem" class="post-meta-item"> 共计
    642 字，约需阅读
    2.33
    分钟
</div>
      </header>
    
    
   

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p><code>WebSocket</code> 是一种在单个 <code>TCP</code> 连接上进行全双工通信的协议，允许服务端主动向客户端推送数据。在 <code>WebSocket API</code> 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><a href="/2021/01/06/nodejs%E4%B8%AD%E5%AE%9E%E7%8E%B0websocket%E6%9C%8D%E5%8A%A1/">nodejs 中实现 websocket 服务</a></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有 2 至 10 字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的 4 字节的掩码。相对于 HTTP 请求每次都要携带完整的头部，此项开销显著减少了。</li>
<li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和 Comet 等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li>
<li>保持连接状态。与 HTTP 不同的是，Websocket 需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而 HTTP 请求可能需要在每个请求都携带状态信息（如身份认证等）。</li>
<li>更好的二进制支持。Websocket 定义了二进制帧，相对 HTTP，可以更轻松地处理二进制内容。</li>
<li>可以支持扩展。Websocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li>
<li>更好的压缩效果。相对于 HTTP 压缩，Websocket 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。</li>
</ul>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p><code>HTTP</code> 请求设置一个较长的超时等待时间，网络请求可以维持一个较长的时间来等待返回结果，如果在等待的时间内有结果会立即返回结果，如果没有结果就会超时自动断开链接，等待下一次请求。</p>
<p><img src="/images/long-poll.svg" alt="长轮询流程"></p>
<h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h3><p>每隔一段时间定时向服务端发起一次请求拉取数据。</p>
<p><img src="/images/poll.svg" alt="短轮询流程"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://baike.baidu.com/item/WebSocket/1953845?fr=aladdin">WebSocket</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/02/%E5%AE%9E%E6%97%B6%E5%8D%8F%E8%AE%AE/" data-id="cm1ghkbng004mzodzbpa1cffq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node/" rel="tag">node</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络-HTTPS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTPS/" class="article-date">
  <time datetime="2021-03-27T20:13:54.000Z" itemprop="datePublished">2021-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTPS/">计算机网络-HTTPS</a>
    </h1>
  


        <div style="color: #999; margin-top: 0.3rem" class="post-meta-item"> 共计
    370 字，约需阅读
    1.35
    分钟
</div>
      </header>
    
    
   

    <div class="article-entry" itemprop="articleBody">
      
        <p><code>HTTPS</code> 协议是通过加入 <code>SSL</code> 层来加密 <code>HTTP</code> 数据进行安全通信的</p>
<h3 id="HTTPS-建立链接的过程"><a href="#HTTPS-建立链接的过程" class="headerlink" title="HTTPS 建立链接的过程"></a><code>HTTPS</code> 建立链接的过程</h3><ol>
<li>客户端发起请求，携带客户端支持加密算法，同时携带随机串 1</li>
<li>服务端收到请求后与自己支持的加密算法进行比对，从双方都支持的加密算法中选择一个返回，同时返回域名相关的公钥和证书签名信息（包括证书时间、日期、颁发机构）及随机串 2</li>
<li>客户端收到响应后验证证书的合法性和公钥的正确性（通过请求证书颁发机构来验证证书的合法性）</li>
<li>证书验证通过后，利用公钥加密一个随机字符串作为后续传输数据的密钥，同时加入利用公钥加密随机串 1 和随机串 2 组成的握手信息，然后发送给服务端</li>
<li>服务端获取到信息后利用私钥进行解密得到客户端生成的随机字符串把它作为后续传输的密钥，利用密钥对传输的随机串 1 和随机串 2 进行加密，然后返回</li>
<li>客户端利用上述生成的随机串对返回的信息进行解密，然后验证其合法性，后续传输就是堆成加密传输</li>
</ol>
<p><img src="/images/https.svg" alt="HTTPS 获取密钥过程"></p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://www.jianshu.com/p/33d0f8631f90">https 建立连接过程</a></li>
<li><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617">HTTP 和 HTTPS 协议，看一篇就够了
</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTPS/" data-id="cm1ghkbno005rzodz47jycmav" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络安全" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/28/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" class="article-date">
  <time datetime="2021-03-27T19:34:30.000Z" itemprop="datePublished">2021-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/28/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a>
    </h1>
  


        <div style="color: #999; margin-top: 0.3rem" class="post-meta-item"> 共计
    1k 字，约需阅读
    3.64
    分钟
</div>
      </header>
    
    
   

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前端攻击"><a href="#前端攻击" class="headerlink" title="前端攻击"></a>前端攻击</h3><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a><code>XSS</code></h4><p>跨站脚本攻击，由插入页面处理的数据未经处理导致。</p>
<ul>
<li>存储型 <code>XSS</code> ：提交的数据未经处理存储到数据库中，然后从数据库中获取数据插入页面导致的</li>
<li>反射型 <code>XSS</code> ：通过 <code>URL</code> 提取参数未经处理直接插入到页面导致</li>
<li><code>MXSS</code> ：渲染 <code>DOM</code> 时插入了攻击脚本（模板渲染）</li>
</ul>
<p>通过字符转义的方式把特殊的符号转化为安全的 <code>HTML</code> 字符（如 &lt;、&gt;等）</p>
<h4 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a><code>SQL</code> 注入攻击</h4><p>结构性查询语言注入攻击，页面提交的数据直接拼接到 <code>SQL</code> 语句进行操作导致，通过对查询数据进行合法性校验即可避免</p>
<h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a><code>CSRF</code></h4><p>跨站请求伪造，非源站点按照源站点数据格式提交非法数据给源站点的一种攻击方式。大部分网站是通过 <code>COOKIE</code> 的方式来验证登录的用户信息，由于浏览器的策略导致请求时会自动携带相关 <code>COOKIE</code>，当非源站点请求源站点数据时也会携带相关 <code>COOKIE</code>，此时构造一个非法的请求也会请求成功。解决办法就是通过在页面中预先植入 <code>TOKEN</code> ，在接口请求时再手动携带上相关的值，由于浏览器的安全策略限制非源站点无法读取相关数据进而导致请求失败</p>
<h3 id="网络劫持"><a href="#网络劫持" class="headerlink" title="网络劫持"></a>网络劫持</h3><p>网络资源请求在请求过程中因为人为的攻击导致没有加载到预期的资源内容。</p>
<h4 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a><code>DNS</code> 劫持</h4><p>攻击者通过篡改 <code>DNS</code> 服务器的域名解析记录，导致用户无法访问正确的网络 <code>IP</code> ，而是访问篡改后的错误 <code>IP</code> 地址。</p>
<h4 id="HTTP-劫持"><a href="#HTTP-劫持" class="headerlink" title="HTTP 劫持"></a><code>HTTP</code> 劫持</h4><p>在用户浏览器和访问的目的服务器之间建立的网络数据传输通道中从网关或防火墙层上监视特定的数据信息，当满足特定条件时，就会在正常的数据包中插入或篡改网络数据包（如 <code>ISP</code> 在部分第三方网站页面中植入广告）。可以通过 <code>HTTPS</code> 协议来预防</p>
<h3 id="浏览器-WEB-安全控制"><a href="#浏览器-WEB-安全控制" class="headerlink" title="浏览器 WEB 安全控制"></a>浏览器 <code>WEB</code> 安全控制</h3><h4 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a><code>X-XSS-Protection</code></h4><p>防止反射型 <code>XSS</code> 问题的发生，浏览器层面增强前端网页的安全性。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">X-XSS-Protection:</span> <span class="number">0</span> <span class="comment"># 禁止XSS过滤。</span></span><br><span class="line"><span class="attr">X-XSS-Protection:</span> <span class="number">1</span> <span class="comment"># 启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。</span></span><br><span class="line"><span class="attr">X-XSS-Protection:</span> <span class="number">1</span><span class="string">;</span> <span class="string">mode=block</span> <span class="comment"># 启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。</span></span><br><span class="line"><span class="attr">X-XSS-Protection:</span> <span class="number">1</span><span class="string">;</span> <span class="string">report=&lt;reporting-uri&gt;</span> <span class="comment"># 启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri (en-US)指令的功能发送违规报告。</span></span><br></pre></td></tr></table></figure>

<h4 id="Strict-Transport-Security"><a href="#Strict-Transport-Security" class="headerlink" title="Strict-Transport-Security"></a><code>Strict-Transport-Security</code></h4><p>配置浏览器和服务器之间安全通信的机制，防止中间者攻击（强制使用 <code>HTTPS</code> 协议，普通协议无效）</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Strict-Transport-Security:</span> <span class="string">max-age=&lt;expire-time&gt;</span> <span class="comment"># 设置在浏览器收到这个请求后的&lt;expire-time&gt;秒的时间内凡是访问这个域名下的请求都使用HTTPS请求。</span></span><br><span class="line"><span class="attr">Strict-Transport-Security:</span> <span class="string">max-age=&lt;expire-time&gt;;</span> <span class="string">includeSubDomains</span> <span class="comment"># 如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。</span></span><br><span class="line"><span class="attr">Strict-Transport-Security:</span> <span class="string">max-age=&lt;expire-time&gt;;</span> <span class="string">preload</span> <span class="comment"># 查看 预加载 HSTS 获得详情。不是标准的一部分。</span></span><br></pre></td></tr></table></figure>

<h4 id="Content-Security-Policy"><a href="#Content-Security-Policy" class="headerlink" title="Content-Security-Policy"></a><code>Content-Security-Policy</code></h4><p>开发者定义的安全策略性声明，浏览器只可以加载指定可信域名来源的内容（包括脚本、图片、<code>iframe</code>、<code>font</code>、<code>style</code> 等）</p>
<h4 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a><code>Access-Control-Allow-Origin</code></h4><p>决定哪些网站可以访问当前服务器资源，通过定义通配符可以让所有网站来访问当前网站的所有资源。若 <code>Access-Control-Allow-Origin</code> 为 <code>*</code>，则 <code>Access-Control-Allow-Credentials</code> 无效。若想 <code>Access-Control-Allow-Credentials</code> 有效（即请求携带 <code>Cookie</code>），则必须明确配置来源。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-XSS-Protection"><code>X-XSS-Protection</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Strict-Transport-Security"><code>Strict-Transport-Security</code></a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP"><code>Content-Security-Policy</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/28/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" data-id="cm1ghkbnm005hzodz8pytfjow" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络-http协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-http%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2021-03-21T16:41:21.000Z" itemprop="datePublished">2021-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-http%E5%8D%8F%E8%AE%AE/">计算机网络-http协议</a>
    </h1>
  


        <div style="color: #999; margin-top: 0.3rem" class="post-meta-item"> 共计
    1.3k 字，约需阅读
    4.73
    分钟
</div>
      </header>
    
    
   

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>无状态、无连接的应用层协议</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器处理完成后立即断开 TCP 连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</p>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p>发布于 1999 年，默认使用文本格式传输数据</p>
<h4 id="长链接"><a href="#长链接" class="headerlink" title="长链接"></a>长链接</h4><p>默认包含 <code>Connection: keep-alive</code> 头，可以让客户端和服务端在一段时间内可以复用这个链接，无需再次建立链接。链接复用发生在应用层，且复用是串行的</p>
<h4 id="支持请求管道化"><a href="#支持请求管道化" class="headerlink" title="支持请求管道化"></a>支持请求管道化</h4><p>基于 HTTP1.1 的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。虽然 HTTP1.1 支持管道化，但是服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。</p>
<p><img src="/images/brower/http_pipe.png" alt="HTTP1.1 支持管道化链接图"></p>
<p>由于“管道化”技术存在各种各样的问题，所以很多浏览器要么根本不支持它，要么就直接默认关闭。</p>
<h4 id="协议扩展切换"><a href="#协议扩展切换" class="headerlink" title="协议扩展切换"></a>协议扩展切换</h4><p>支持在请求头部域消息中包含 <code>Upgrade</code> 头并让客户端通过头部标识令服务器知道它能够支持其它备用通信协议的一种机制，服务器根据客户端请求的其它协议进行切换，切换后使用备用协议与客户端进行通信</p>
<h4 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h4><p>新增 <code>Cache-Control</code> 字段，支持 <code>max-age</code> 用来表示相对过期时间；服务器也可以通过 <code>Etag</code> 和 <code>Last-Modified</code> 来判断是否从浏览器中加载文件，此时缓存的控制和判断将决定响应状态码是 200 还是 304。参考<a href="/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">浏览器缓存</a>章节</p>
<h4 id="部分内容传输优化"><a href="#部分内容传输优化" class="headerlink" title="部分内容传输优化"></a>部分内容传输优化</h4><p>引入了 <code>range</code> 头域支持超文本文件的部分传输。如允许请求一个文件的起始位置和偏移长度来进行文件内容的部分传输</p>
<h4 id="Host-头处理"><a href="#Host-头处理" class="headerlink" title="Host 头处理"></a>Host 头处理</h4><p>请求消息和响应消息都支持 <code>Host</code> 头域，且请求消息中如果没有 <code>Host</code> 头域会报告一个错误（<code>400 Bad Request</code>）</p>
<h4 id="错误通知的管理"><a href="#错误通知的管理" class="headerlink" title="错误通知的管理"></a>错误通知的管理</h4><p>新增了 <code>24</code> 个错误状态响应码，如 <code>409（Conflict）</code>表示请求的资源与资源的当前状态发生冲突；<code>410（Gone）</code>表示服务器上的某个资源被永久性的删除。</p>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><ul>
<li>采用完全的二进制格式来传输数据，其在网络中以帧的形式传播，多个帧在网络中形成了帧的传输网络流，即流式传播的。</li>
<li>使用 <code>TCP</code> 复用的方式来降低网络请求链接的建立和关闭的开销，多个请求可以通过一个链接来进行并发完成。复用发生在传输层，是帧的多路复用，不同文件的传输可以在一个 <code>TCP</code> 连接中一起同时进行流式传播</li>
<li>支持传输流的优先级和流量控制机制</li>
<li>支持服务端推送</li>
</ul>
<h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>通过在应用层和传输层之间增加一个二进制分帧层，突破了 HTTP1.1 的性能限制、改进传输性能。</p>
<p><img src="/images/brower/http_bf.jpg" alt="二进制分帧结构图"></p>
<h4 id="多路复用（连接共享）"><a href="#多路复用（连接共享）" class="headerlink" title="多路复用（连接共享）"></a>多路复用（连接共享）</h4><ul>
<li>流（stream）：已建立连接上的双向字节流。</li>
<li>消息：与逻辑消息对应的完整的一系列数据帧。</li>
<li>帧（frame）：HTTP2.0 通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（stream id）。</li>
</ul>
<p><img src="/images/brower/http_stream.jpg" alt="多路复用（连接共享）"></p>
<p>所有的 HTTP2.0 通信都在一个 TCP 连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装。</p>
<h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p>使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩 header，减少发送包的数量从而降低延迟。</p>
<p>在头部压缩技术中，客户端和服务器均会维护两份相同的静态字典和动态字典。在静态字典中，包含了常见的头部名称以及头部名称与值的组合。静态字典在首次请求时就可以使用。那么现在头部的字段就可以被简写成静态字典中相应字段对应的 index。而动态字典跟连接的上下文相关，每个 HTTP&#x2F;2 连接维护的动态字典是不尽相同的。动态字典可以在连接中不听的进行更新。原本完整的 HTTP 报文头部的键值对或字段，由于字典的存在，现在可以转换成索引 index，在相应的端再进行查找还原，也就起到了压缩的作用。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.jianshu.com/p/be29d679cbff">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></li>
<li><a href="https://segmentfault.com/a/1190000013028798?utm_source=tag-newest">HTTP1.0 HTTP1.1 HTTP2.0 主要特性对比</a></li>
<li><a href="https://www.jianshu.com/p/52d86558ca57">如何优雅的谈论 HTTP／1.0／1.1／2.0</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-http%E5%8D%8F%E8%AE%AE/" data-id="cm1ghkbno005vzodz1nz494q5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-commonjs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/03/commonjs/" class="article-date">
  <time datetime="2021-03-02T23:44:49.000Z" itemprop="datePublished">2021-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/03/commonjs/">commonjs</a>
    </h1>
  


        <div style="color: #999; margin-top: 0.3rem" class="post-meta-item"> 共计
    878 字，约需阅读
    3.19
    分钟
</div>
      </header>
    
    
   

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="commonjs-规范"><a href="#commonjs-规范" class="headerlink" title="commonjs 规范"></a>commonjs 规范</h3><ul>
<li>模块引用：通过 <code>require</code> 方法把模块引入上下文</li>
<li>模块定义：模块中通过 <code>exports</code> 属性导出模块的方法和变量，<code>module</code> 代表模块自身</li>
<li>模块标识：传递给 <code>require</code> 方法的参数</li>
</ul>
<h3 id="node-实现"><a href="#node-实现" class="headerlink" title="node 实现"></a>node 实现</h3><h5 id="引入模块的流程"><a href="#引入模块的流程" class="headerlink" title="引入模块的流程"></a>引入模块的流程</h5><ol>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ol>
<h5 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h5><ol>
<li>核心模块：<code>Node</code> 源代码的编译过程中，编译进了二进制执行文件。<code>Node</code> 启动时已经被加载入内存中</li>
<li>文件模块：运行时动态加载</li>
</ol>
<h4 id="模块缓存"><a href="#模块缓存" class="headerlink" title="模块缓存"></a>模块缓存</h4><ol>
<li>引入过的模块都会进行缓存</li>
<li>缓存优先</li>
</ol>
<h4 id="路径分析和文件定位"><a href="#路径分析和文件定位" class="headerlink" title="路径分析和文件定位"></a>路径分析和文件定位</h4><h5 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h5><p><code>Node</code> 中在定位文件模块的具体文件时制定的查找策略，根据查找规则生成查找路径数组，查找规则如下</p>
<ol>
<li>查找当前目录下的 <code>node_modules</code> 目录</li>
<li>父目录下的 <code>node_modules</code> 目录</li>
<li>沿着路径向上逐级递归直到找到根目录的 <code>node_modules</code> 目录</li>
</ol>
<h5 id="模块标志符分析"><a href="#模块标志符分析" class="headerlink" title="模块标志符分析"></a>模块标志符分析</h5><ul>
<li>核心模块</li>
<li>相对路径模块和绝对路径模块：转化为真实路径作为索引来查找和缓存模块</li>
<li>非路径形式的文件模块</li>
</ul>
<h5 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h5><ul>
<li>文件扩展名分析：<code>Node</code> 会按照 <code>.js</code>、<code>.json</code>、<code>.node</code>的次序依次尝试扩展名，尝试过程中会阻塞式的判断文件是否存在</li>
<li>目录分析与包：分析标识符得到一个文件夹时，<code>Node</code> 会按照 <code>package.json</code>、<code>index.js</code>、<code>index.json</code>、<code>index.node</code>来查找文件，若查找到 <code>package.json</code> 会提取 <code>main</code> 指定的文件来进行定位</li>
</ul>
<h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>定位到具体的文件之后，<code>Node</code> 会构建一个模块对象，然后根据路径载入并编译</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Module</span>(<span class="params">id, parent</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parent</span> = parent</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">exports</span> = &#123;&#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">filename</span> = <span class="literal">null</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">loaded</span> = <span class="literal">false</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">children</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.<span class="property">children</span>) &#123;</span><br><span class="line">    parent.<span class="property">children</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不同扩展名的载入方式"><a href="#不同扩展名的载入方式" class="headerlink" title="不同扩展名的载入方式"></a>不同扩展名的载入方式</h5><ul>
<li><code>.js</code> 文件：通过 <code>fs</code> 模块同步读取文件后编译执行</li>
<li><code>.node</code> 文件：<code>c/c++</code> 写的扩展文件，通过 <code>dlopen()</code> 方法加载编译生成的文件</li>
<li><code>.json</code> 文件：通过 <code>fs</code> 模块同步读取文件后返回 <code>JSON.parse</code> 的结果</li>
<li>其它类型的文件：当作 <code>.js</code> 文件来处理</li>
</ul>
<h6 id="注：-可以通过-require-extensions-ext-的方式来扩展方式，但是已不推荐"><a href="#注：-可以通过-require-extensions-ext-的方式来扩展方式，但是已不推荐" class="headerlink" title="注： 可以通过 require.extensions[&quot;.ext&quot;] 的方式来扩展方式，但是已不推荐"></a>注： 可以通过 <code>require.extensions[&quot;.ext&quot;]</code> 的方式来扩展方式，但是已不推荐</h6><h5 id="JavaScript-模块的编译"><a href="#JavaScript-模块的编译" class="headerlink" title="JavaScript 模块的编译"></a><code>JavaScript</code> 模块的编译</h5><p><code>Node</code> 对获取的 <code>JavaScript</code> 文件内容做了包装，在头部添加了 <code>(function(exports, require, module, __filename, __dirname)&#123;\n</code>，在尾部添加了 <code>\n&#125;)</code>，包装之后的代码会通过 <code>vm</code> 原生的 <code>runInThisContext()</code> 方法执行，返回一个 <code>function</code> 对象，然后将当前模块对象的 <code>exports</code> 属性、<code>require</code> 方法、 <code>module</code>（模块对象自身）、模块定位中的完整文件路径和目录作为参数传递给这个函数执行，执行之后模块的 <code>exports</code> 属性被返回给了调用方</p>
<h6 id="注：-exports-属性是作为形参传入的，直接赋值会改变形参的引用，通过-module-exports-赋值采用迂回的方案不改变形参的引用"><a href="#注：-exports-属性是作为形参传入的，直接赋值会改变形参的引用，通过-module-exports-赋值采用迂回的方案不改变形参的引用" class="headerlink" title="注： exports 属性是作为形参传入的，直接赋值会改变形参的引用，通过 module.exports 赋值采用迂回的方案不改变形参的引用"></a>注： <code>exports</code> 属性是作为形参传入的，直接赋值会改变形参的引用，通过 <code>module.exports</code> 赋值采用迂回的方案不改变形参的引用</h6><h5 id="c-c-模块的编译"><a href="#c-c-模块的编译" class="headerlink" title="c/c++ 模块的编译"></a><code>c/c++</code> 模块的编译</h5><p><code>Node</code> 调用 <code>process.dlopen</code> 方法进行加载和执行，模块的 <code>exports</code> 对象和 <code>.node</code> 模块产生联系并返回给调用者</p>
<ul>
<li>优点： 执行效率高</li>
<li>缺点：门槛高</li>
</ul>
<h5 id="JSON-文件的编译"><a href="#JSON-文件的编译" class="headerlink" title="JSON 文件的编译"></a><code>JSON</code> 文件的编译</h5><p><code>Node</code> 利用 <code>fs</code> 模块同步读取 <code>JSON</code> 文件内容之后，调用 <code>JSON.parse</code> 方法得到对象，然后赋值给对象的 <code>exports</code> 属性供外部调用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/03/commonjs/" data-id="cm1ghkbmm000mzodz5tprdr3b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node/" rel="tag">node</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浏览器基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2021-03-01T23:06:23.000Z" itemprop="datePublished">2021-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/">浏览器基础</a>
    </h1>
  


        <div style="color: #999; margin-top: 0.3rem" class="post-meta-item"> 共计
    474 字，约需阅读
    1.72
    分钟
</div>
      </header>
    
    
   

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h3><h4 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h4><p>包括浏览器中可见的地址输入框、浏览器前进返回按钮、打开书签、打开历史记录等用户可操作的功能选项</p>
<h4 id="浏览器引擎"><a href="#浏览器引擎" class="headerlink" title="浏览器引擎"></a>浏览器引擎</h4><p>可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器各个部分通信的核心。</p>
<h4 id="渲染引擎（内核）"><a href="#渲染引擎（内核）" class="headerlink" title="渲染引擎（内核）"></a>渲染引擎（内核）</h4><p>解析 <code>DOM</code> 文档和 <code>CSS</code> 规则并将内容排版到浏览器中显示有样式的界面</p>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>开启网络线程发送请求或下载资源文件</p>
<h4 id="UI-后端"><a href="#UI-后端" class="headerlink" title="UI 后端"></a>UI 后端</h4><p>绘制基本的浏览器窗口内的控件，比如组合选择框、按钮、输入框等</p>
<h4 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a><code>JavaScript</code> 引擎</h4><p>解析和执行 <code>JavaScript</code> 脚本，比如 <code>V8</code> 引擎</p>
<h4 id="持久化数据存储"><a href="#持久化数据存储" class="headerlink" title="持久化数据存储"></a>持久化数据存储</h4><p>数据持久化存储，涉及 <code>cookie</code> 、 <code>localStorage</code> 等客户端存储技术</p>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><ol>
<li>解析 <code>HTML</code> 构建 <code>DOM</code>树：将 HTML 元素标签解析成由多个 DOM 元素对象节点组成的具有节点父子关系的 DOM 树结构</li>
<li>构建渲染树：按顺序提取 DOM 元素对象的样式数据，构建带样式描述的 DOM 渲染树对象</li>
<li>渲染布局阶段：根据节点的大小和位置把元素绘制在页面上，主要是布局属性（例如： postion、float、margin、padding 等）生效</li>
<li>绘制渲染树：将节点的背景、颜色、文本等样式信息应用到节点上，主要是元素的内部显示样式（例如： color、background、text-shadow 等）生效</li>
</ol>
<h4 id="gecko-内核渲染流程"><a href="#gecko-内核渲染流程" class="headerlink" title="gecko 内核渲染流程"></a>gecko 内核渲染流程</h4><p>先解析 HTM，生成内容 Sink （Content Sink 可以认为是构建 DOM 结构树的工厂方法），再开始解析 CSS</p>
<p><img src="/images/brower/gecko.svg" alt="gecko内核渲染流程"></p>
<h4 id="webkit-内核渲染流程"><a href="#webkit-内核渲染流程" class="headerlink" title="webkit 内核渲染流程"></a>webkit 内核渲染流程</h4><p>HTML 和 CSS 的解析是并行的</p>
<p><img src="/images/brower/webkit.svg" alt="webkit内核渲染流程"></p>
<h3 id="持久化技术"><a href="#持久化技术" class="headerlink" title="持久化技术"></a>持久化技术</h3><ul>
<li><a href="/2020/08/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/">HTTP 文件缓存</a></li>
<li><code>localStorage</code></li>
<li><code>sessionStorage</code></li>
<li><code>cookie</code></li>
<li><code>webSQL</code></li>
<li><code>Application cache</code></li>
<li><code>cacheStorage</code></li>
<li><code>flash</code> 缓存</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/" data-id="cm1ghkbnj0053zodz48u02ecn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/">下一页 &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-language/" rel="tag">C&#x2F;C++语言</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">63</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeORM/" rel="tag">TypeORM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/antd/" rel="tag">antd</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/" rel="tag">express</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/form/" rel="tag">form</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/other/" rel="tag">other</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6/" rel="tag">插件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solution/" rel="tag">算法</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/" rel="tag">计算机网络</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/read-book/" rel="tag">读书</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/source/" rel="tag">资源</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/c-language/" style="font-size: 12.5px;">C/C++语言</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/TypeORM/" style="font-size: 10px;">TypeORM</a> <a href="/tags/TypeScript/" style="font-size: 11.25px;">TypeScript</a> <a href="/tags/antd/" style="font-size: 10px;">antd</a> <a href="/tags/express/" style="font-size: 11.25px;">express</a> <a href="/tags/form/" style="font-size: 10px;">form</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/mysql/" style="font-size: 12.5px;">mysql</a> <a href="/tags/node/" style="font-size: 18.75px;">node</a> <a href="/tags/other/" style="font-size: 16.25px;">other</a> <a href="/tags/react/" style="font-size: 17.5px;">react</a> <a href="/tags/webpack/" style="font-size: 12.5px;">webpack</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 10px;">插件</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a> <a href="/tags/solution/" style="font-size: 13.75px;">算法</a> <a href="/tags/network/" style="font-size: 15px;">计算机网络</a> <a href="/tags/read-book/" style="font-size: 10px;">读书</a> <a href="/tags/source/" style="font-size: 12.5px;">资源</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/24/%E8%AE%B0%E4%B8%80%E6%AC%A1safari%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">记一次safari白屏问题排查</a>
          </li>
        
          <li>
            <a href="/2024/09/25/%E6%AD%A3%E5%88%99/">正则</a>
          </li>
        
          <li>
            <a href="/2024/09/25/AI/">AI</a>
          </li>
        
          <li>
            <a href="/2024/09/24/zustand/">zustand</a>
          </li>
        
          <li>
            <a href="/2024/09/22/typescript%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0/">typescript自定义实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 奔跑的蜗牛<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">分类</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>